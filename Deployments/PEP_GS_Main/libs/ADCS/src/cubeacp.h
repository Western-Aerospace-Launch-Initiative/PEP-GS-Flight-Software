/************************************************************************************
 * This file was auto-generated by CIDEA                           .                *
 * Please do not modify the contents of this file manually.                         *
 ***********************************************************************************/

#ifndef __CUBEACP7_H
#define __CUBEACP7_H

#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>

#include "types.h"

#ifdef __cplusplus
extern "C" {
#endif

/***************************************************************************//**
* @addtogroup CubeComponents
* @{
******************************************************************************/

/***************************************************************************//**
* @addtogroup CubeComputer4ControlProgram
* @brief CubeACP Interface API
* @{
******************************************************************************/

/// CubeComputer4ControlProgram Telemetry enumeration
typedef enum {
    AcpLoopState = 220, ///< Returns information about the ACP loop
    ActuatorCmd = 192, ///< Actuator commands
    AdcsConfig = 206, ///< Current configuration
    AdcsExecTimes = 196, ///< Returns information about execution times of ACP functions
    AdcsMeasure = 191, ///< Calibrated sensor measurements
    AdcsMiscCurrents = 198, ///< CubeStar and Torquer current and temperature measurements
    AdcsPower = 197, ///< Control power to selected components
    AdcsPowerMeasure = 195, ///< Power and temperature measurements
    AdcsState = 190, ///< Current ADCS state
    AdcsSystemConfig = 225, ///< Current hard-coded system configuration
    AdcsTemperatures1 = 174, ///< Magnetometer + MCU temperature measurements
    AdcsTemperatures2 = 175, ///< Rate sensor temperatures
    Asgp4KepTle = 228, ///< ASGP4 TLEs generated
    ASgp4Params = 227, ///< Settings for GPS augmented SGP4
    CmdAttitude = 199, ///< Commanded attitude angles
    CmdTrackingTarget = 200, ///< Target reference for tracking control mode
    CoarseSunVec = 152, ///< Measured coarse sun vector
    ConversionProgress = 133, ///< Conversion progress
    CssConfig = 139, ///< Photodiode pointing directions and scale factors
    CubeACPState = 135, ///< Contains flags regarding the state of the ACP
    CubeControlCurrents = 172, ///< CubeControl current measurements
    CubeSense1Currents = 171, ///< CubeSense1 current measurements
    CubeSense2Currents = 232, ///< CubeSense2 current measurements
    CubeSenseConfig = 203, ///< CubeSense configuration parameters
    CurrentAdcsState = 132, ///< Current state of the Attitude Control Processor - frame 1
    CurrentAdcsState2 = 224, ///< Current state of the Attitude Control Processor - frame 2
    DetumbleParams = 208, ///< Set controller gains and reference values for Detumbling control mode
    EstimAttitude = 146, ///< Estimated attitude angles
    EstimData = 193, ///< Estimation meta-data
    EstimGyroBias = 161, ///< Estimated rate sensor bias
    EstimParams = 223, ///< Estimation noise covariance and sensor mask
    EstimQuaternion = 218, ///< Estimated quaternion set
    EstimRates = 147, ///< Estimated angular rates relative to orbit reference frame
    FineEstimRates = 201, ///< High resolution estimated angular rates relative to orbit reference frame
    FineSunVec = 153, ///< Measured fine sun vector
    GyroConfig = 138, ///< Set rate gyro configuration parameters
    ImageSaveStatus = 233, ///< Status of Image Capture and Save Operation
    InertialPointReference = 238, ///< Reference unit vector for inertial pointing control mode
    InnovationVec = 162, ///< Estimation innovation vector
    LogSdConfig1 = 235, ///< Log selection and period for LOG1
    LogSdConfig2 = 236, ///< Log selection and period for LOG2
    LogUartConfig = 237, ///< Log selection and period for UART (unsolicited TLM)
    MagConfig = 204, ///< Magnetometer configuration parameters
    MagField = 151, ///< Measured magnetic field vector
    MagRaw2 = 215, ///< Secondary Magnetometer raw measurements
    MagtorqConfig = 136, ///< Set magnetorquer configuration parameters
    MagTorquerCmd = 157, ///< Magnetorquer commands
    ModelMagVec = 159, ///< IGRF modelled magnetic field vector (orbit frame referenced)
    ModelSunVec = 160, ///< Modelled sun vector (orbit frame referenced)
    MoI = 222, ///< Satellite moment of inertia matrix
    NadirVec = 154, ///< Measured nadir vector
    OrbitParameters = 207, ///< SGP4 Orbit Parameters
    PositionECEF = 219, ///< Satellite position in ECEF coordinates
    PositionECI = 148, ///< Satellite position in ECI frame
    PositionLLH = 150, ///< Satellite position in WGS-84 coordinate frame
    QuaternionCovar = 164, ///< Quaternion covariance
    QuaternionErrVec = 163, ///< Quaternion error vector
    RateCovar = 165, ///< Angular rate covariance
    RateSensor = 155, ///< Rate sensor measurements
    RawCam1Sens = 167, ///< Cam1 sensor capture and detection result
    RawCam2Sens = 166, ///< Cam2 sensor capture and detection result
    RawCss1 = 168, ///< Raw CSS measurements 1 to 6
    RawCss2 = 169, ///< Raw CSS measurements 7 to 10
    RawGPS = 210, ///< Raw GPS measurements
    RawGpsStatus = 176, ///< Raw GPS status
    RawGpsTime = 177, ///< Raw GPS time
    RawGpsX = 178, ///< Raw GPS X position and velocity (ECI referenced)
    RawGpsY = 179, ///< Raw GPS Y position and velocity (ECI referenced)
    RawGpsZ = 180, ///< Raw GPS Z position and velocity (ECI referenced)
    RawMagnetometer = 170, ///< Raw magnetometer measurements
    RawRate = 216, ///< Raw rate sensor measurements
    RawSensor = 194, ///< Raw sensor measurements
    RawStarTracker = 211, ///< Raw Star Tracker Measurement
    RedMagConfig = 205, ///< Redundant magnetometer configuration parameters
    RWheelParams = 217, ///< Set controller gains and reference value for reaction wheel control mode
    SpeedCmd = 158, ///< Wheel speed commands
    Star1Body = 181, ///< Star 1 Body Vector
    Star1Orbit = 184, ///< Star 1 Orbit Vector
    Star1Raw = 212, ///< Catalogue index and detected coordinates for star 1
    Star2Body = 182, ///< Star 2 Body Vector
    Star2Orbit = 185, ///< Star 2 Orbit Vector
    Star2Raw = 213, ///< Catalogue index and detected coordinates for star 2
    Star3Body = 183, ///< Star 3 Body Vector
    Star3Orbit = 186, ///< Star 3 Orbit Vector
    Star3Raw = 214, ///< Catalogue index and detected coordinates for star 3
    StarConfig = 202, ///< Set configurations of CubeStar
    StarEstimQ = 230, ///< Attitude quaternion estimated by CubeStar
    StarEstimRate = 229, ///< Angular rates estimated by CubeStar
    StarMagnitude = 187, ///< Instrument magnitude of identified stars
    StarPerformance1 = 188, ///< Performance parameters of star measurement
    StarPerformance2 = 231, ///< Performance parameters of star measurement
    StarTiming = 189, ///< Timing information of star measurement
    TrackingParams = 221, ///< Set controller gains for tracking control mode
    UserConEstParams = 226, ///< Settings for user-coded estimation and control modes
    VelocityECI = 149, ///< Satellite velocity in ECI frame
    WheelConfig = 137, ///< Set  wheel configuration parameters
    WheelCurrents = 173, ///< XYZ Wheel current measurement
    WheelSpeed = 156, ///< Wheel speed measurement
    YWheelParams = 209, ///< Set controller gains and reference value for Y-wheel control mode
} CUBEACP_Telemetry_t; 

/// AcpProgramType enumeration
typedef enum {
    AcpProgramType_Acp3Axis = 0, ///< 3-Axis ACP
    AcpProgramType_AcpYMom = 1, ///< Y-Momentum ACP
} CUBEACP_AcpProgramType_t;

/// AdcsRunMode enumeration
typedef enum {
    AdcsRunMode_AdcsOff = 0, ///< ADCS loop is inactive
    AdcsRunMode_AdcsEnabled = 1, ///< ADCS 1Hz loop is active
    AdcsRunMode_AdcsTriggered = 2, ///< ADCS will execute control loop only when triggered
    AdcsRunMode_AdcsSimulation = 3, ///< ADCS is in simulation mode
} CUBEACP_AdcsRunMode_t;

/// Asgp4Error enumeration
typedef enum {
    Asgp4Error_Asgp4None = 0, ///< No error
    Asgp4Error_Asgp4UnixTime = 1, ///< Error due to time
    Asgp4Error_Asgp4LargePositionError = 2, ///< Error due to position error exceeding threshold
    Asgp4Error_Asgp4Overflow = 3, ///< Error overflow
} CUBEACP_Asgp4Error_t;

/// Asgp4ModeSelect enumeration
typedef enum {
    Asgp4ModeSelect_Asgp4Off = 0, ///< ASGP4 is inactive
    Asgp4ModeSelect_Asgp4Trigger = 1, ///< ASGP4 is active but waiting for trigger TC
    Asgp4ModeSelect_Asgp4Background = 2, ///< ASGP4 runs asynchronously with GPS data received, TLEs updated internal to asgp4 module but not used
    Asgp4ModeSelect_Asgp4Augment = 3, ///< ASGP4 runs in background but when processing of data is complete, TLEs used by orbit model is updated with asgp4 estimated TLEs
} CUBEACP_Asgp4ModeSelect_t;

/// AsgpFilter enumeration
typedef enum {
    AsgpFilter_Asgp4Lpf = 0, ///< Use LPF
    AsgpFilter_Asgp4Average = 1, ///< Use averaging filter
} CUBEACP_AsgpFilter_t;

/// AxisSelect enumeration
typedef enum {
    AxisSelect_PosX = 0, ///< Positive X
    AxisSelect_NegX = 1, ///< Negative X
    AxisSelect_PosY = 2, ///< Positive Y
    AxisSelect_NegY = 3, ///< Negative Y
    AxisSelect_PosZ = 4, ///< Positive Z
    AxisSelect_NegZ = 5, ///< Negative Z
    AxisSelect_NotUsed = 6, ///< Not Used
    AxisSelect_PosXPosY45deg = 7, ///< Positive X/Y 45 degree
} CUBEACP_AxisSelect_t;

/// CamSelect enumeration
typedef enum {
    CamSelect_CamCam1 = 0, ///< Cam1 camera
    CamSelect_CamCam2 = 1, ///< Cam2 camera
    CamSelect_CamStar = 2, ///< Star camera
} CUBEACP_CamSelect_t;

/// CaptureResult enumeration
typedef enum {
    CaptureResult_CaptureStartup = 0, ///< Start-up
    CaptureResult_CapturePending = 1, ///< Capture pending
    CaptureResult_CaptureSuccess = 2, ///< Successfully captured
    CaptureResult_CaptureSuccessShift = 3, ///< Successfully captured on other SRAM (only applicable to CubeSense V2 hardware)
    CaptureResult_CaptureTimeout = 4, ///< Camera timeout
    CaptureResult_CaptureSRAMErr = 5, ///< SRAM overcurrent
} CUBEACP_CaptureResult_t;

/// ConModeSelect enumeration
typedef enum {
    ConModeSelect_ConNone = 0, ///< No control
    ConModeSelect_ConBdot = 1, ///< Detumbling control
    ConModeSelect_ConYspin = 2, ///< Y-Thomson spin
    ConModeSelect_ConYwheelInit = 3, ///< Y-Wheel momentum stabilized - Initial Pitch Acquisition
    ConModeSelect_ConYwheel = 4, ///< Y-Wheel momentum stabilized - Steady State
    ConModeSelect_ConXYZwheel = 5, ///< XYZ-Wheel control
    ConModeSelect_ConRWSunTrack = 6, ///< Rwheel sun tracking control
    ConModeSelect_ConRWTargetTrack = 7, ///< Rwheel target tracking control
    ConModeSelect_ConVeryFastDetumbling = 8, ///< 10Hz Detumbling control within CubeControl
    ConModeSelect_ConFastDetumbling = 9, ///< Fast Detumbling control
    ConModeSelect_ConSpecial1 = 10, ///< User defined, or custom control mode 1
    ConModeSelect_ConSpecial2 = 11, ///< User defined, or custom control mode 2
    ConModeSelect_ConStopRW = 12, ///< Stop all R-wheels
    ConModeSelect_ConUser = 13, ///< User coded control mode
    ConModeSelect_ConRWSunRollYawSteer = 14, ///< Yaw-only or roll-only sun tracking mode.
    ConModeSelect_ConRWTargetYawSteer = 15, ///< Yaw-only wheel control to align selected facet to ground target
} CUBEACP_ConModeSelect_t;

/// CsCamType enumeration
typedef enum {
    CsCamType_CamTypeSun = 0, ///< Sun Sensor
    CsCamType_CamTypeNadir = 1, ///< Nadir Sensor
} CUBEACP_CsCamType_t;

/// DetectResult enumeration
typedef enum {
    DetectResult_DetectStartup = 0, ///< Start-up
    DetectResult_DetectNoDetect = 1, ///< No detection scheduled
    DetectResult_DetectPending = 2, ///< Detection pending
    DetectResult_DetectTooManyEdges = 3, ///< Nadir error - too many detected edges
    DetectResult_DetectTooFewEdges = 4, ///< Nadir error - not enough edges detected
    DetectResult_DetectBadFit = 5, ///< Nadir error - bad fit
    DetectResult_DetectSunNotFound = 6, ///< Sun error - sun not found
    DetectResult_DetectSuccess = 7, ///< Successful detection
} CUBEACP_DetectResult_t;

/// EstimModeSelect enumeration
typedef enum {
    EstimModeSelect_EstNone = 0, ///< No attitude estimation
    EstimModeSelect_EstMemsRate = 1, ///< MEMS rate sensing
    EstimModeSelect_EstMagRkf = 2, ///< Magnetometer rate filter
    EstimModeSelect_EstPitchRkf = 3, ///< Magnetometer rate filter with pitch estimation
    EstimModeSelect_EstTriad = 4, ///< Magnetometer and Fine-sun TRIAD algorithm
    EstimModeSelect_EstFullEkf = 5, ///< Full-state EKF
    EstimModeSelect_EstGyroEkf = 6, ///< MEMS gyro EKF
    EstimModeSelect_EstUser = 7, ///< User coded estimation mode
} CUBEACP_EstimModeSelect_t;

/// ExecutionWaypoints enumeration
typedef enum {
    ExecutionWaypoints_Init = 0, ///< Busy with initialization
    ExecutionWaypoints_Idle = 1, ///< Idle
    ExecutionWaypoints_SensorActuatorComms = 2, ///< Sensor/Actuator Communications
    ExecutionWaypoints_AdcsUpdate = 3, ///< ADCS Estimation & Control Update
    ExecutionWaypoints_PeripheralPowerSet = 4, ///< Perhipheral Power commands (over I2C)
    ExecutionWaypoints_SampleTemperature = 5, ///< CPU Temperature Sampling
    ExecutionWaypoints_ImageDownload = 6, ///< Image Download
    ExecutionWaypoints_ImageCompression = 7, ///< Image Compression
    ExecutionWaypoints_ImageSaveToSd = 8, ///< Saving Image to SD Card
    ExecutionWaypoints_Logging = 9, ///< Logging
    ExecutionWaypoints_LogCompression = 10, ///< Log File Compression
    ExecutionWaypoints_LogSaveToSd = 11, ///< Saving Log to SD Card
    ExecutionWaypoints_WritingToFlash = 12, ///< Writing to flash memory
} CUBEACP_ExecutionWaypoints_t;

/// GpioPort enumeration
typedef enum {
    GpioPort_PortA = 0, ///< Port A
    GpioPort_PortB = 1, ///< Port B
    GpioPort_PortC = 2, ///< Port C
    GpioPort_PortD = 3, ///< Port D
    GpioPort_PortE = 4, ///< Port E
    GpioPort_PortF = 5, ///< Port F
} CUBEACP_GpioPort_t;

/// GpioPortPin enumeration
typedef enum {
    GpioPortPin_PortPin0 = 0, ///< Pin 0
    GpioPortPin_PortPin1 = 1, ///< Pin 1
    GpioPortPin_PortPin2 = 2, ///< Pin 2
    GpioPortPin_PortPin3 = 3, ///< Pin 3
    GpioPortPin_PortPin4 = 4, ///< Pin 4
    GpioPortPin_PortPin5 = 5, ///< Pin 5
    GpioPortPin_PortPin6 = 6, ///< Pin 6
    GpioPortPin_PortPin7 = 7, ///< Pin 7
    GpioPortPin_PortPin8 = 8, ///< Pin 8
    GpioPortPin_PortPin9 = 9, ///< Pin 9
    GpioPortPin_PortPin10 = 10, ///< Pin 10
    GpioPortPin_PortPin11 = 11, ///< Pin 11
    GpioPortPin_PortPin12 = 12, ///< Pin 12
    GpioPortPin_PortPin13 = 13, ///< Pin 13
    GpioPortPin_PortPin14 = 14, ///< Pin 14
    GpioPortPin_PortPin15 = 15, ///< Pin 15
} CUBEACP_GpioPortPin_t;

/// GpsSelect enumeration
typedef enum {
    GpsSelect_GpsNone = 0, ///< No GPS support
    GpsSelect_GpsNovatel = 1, ///< Novatel GPS
    GpsSelect_GpsSkyfox = 2, ///< Skyfox GPS
} CUBEACP_GpsSelect_t;

/// GpsSolutionStatus enumeration
typedef enum {
    GpsSolutionStatus_SolutionComputed = 0, ///< Solution computed
    GpsSolutionStatus_InsufficientObs = 1, ///< Insufficient observations
    GpsSolutionStatus_NoConvergence = 2, ///< No convergence
    GpsSolutionStatus_Singularity = 3, ///< Singularity at parameters matrix
    GpsSolutionStatus_CovTrace = 4, ///< Covariance trace exceeds maximum
    GpsSolutionStatus_ColdStart = 5, ///< Not yet converged from cold start
    GpsSolutionStatus_VhLimit = 6, ///< Height or velocity limits exceeded
    GpsSolutionStatus_Variance = 7, ///< Variance exceeds limits
    GpsSolutionStatus_IntegrityWarning = 8, ///< Large residuals make position unreliable
    GpsSolutionStatus_Pending = 9, ///< Calculating comparison to user provided
    GpsSolutionStatus_InvalidFix = 10, ///< The fixed position is invalid
    GpsSolutionStatus_Unauthorized = 11, ///< Position type is unauthorized
} CUBEACP_GpsSolutionStatus_t;

/// ImSaveStatus enumeration
typedef enum {
    ImSaveStatus_ImgSaveNoError = 0, ///< No Error
    ImSaveStatus_CameraTimeout = 1, ///< Timeout waiting for sensor to become available
    ImSaveStatus_DownloadTimeout = 2, ///< Timeout waiting for next frame to become ready
    ImSaveStatus_DownloadChecksum = 3, ///< Checksum mismatch between downloaded frame and unit frame
    ImSaveStatus_SdCardError = 4, ///< Error writing to SD card
} CUBEACP_ImSaveStatus_t;

/// ImSize enumeration
typedef enum {
    ImSize_Size0 = 0, ///< 1024 x 1024 pixels
    ImSize_Size1 = 1, ///< 512 x 512 pixels
    ImSize_Size2 = 2, ///< 256 x 256 pixels
    ImSize_Size3 = 3, ///< 128 x 128 pixels
    ImSize_Size4 = 4, ///< 64 x 64 pixels
} CUBEACP_ImSize_t;

/// JpgConvertResult enumeration
typedef enum {
    JpgConvertResult_NoConversion = 0, ///< Nothing Converted Yet
    JpgConvertResult_ConvertOk = 1, ///< Success
    JpgConvertResult_FileLoadError = 2, ///< File Load Error
    JpgConvertResult_BusyConverting = 3, ///< Busy
} CUBEACP_JpgConvertResult_t;

/// MagModeVal enumeration
typedef enum {
    MagModeVal_SigMainMag = 0, ///< Main magnetometer, sampled through signal microcontroller
    MagModeVal_SigRedMag = 1, ///< Redundant magnetometer, sampled through signal microcontroller
    MagModeVal_MotorMainMag = 2, ///< Main magnetometer, sampled through motor microcontroller
    MagModeVal_None = 3, ///< None
} CUBEACP_MagModeVal_t;

/// NadirResult enumeration
typedef enum {
    NadirResult_NadirNoError = 0, ///< No Error
    NadirResult_NadirTimeout = 1, ///< Camera timeout
    NadirResult_NadirOvercurrent = 4, ///< Nadir SRAM Overcurrent detected
    NadirResult_NadirTooManyEdges = 10, ///< Too many edges
    NadirResult_NadirNotEnoughEdges = 11, ///< Not enough edges
    NadirResult_NadirMatrixErr = 12, ///< Matrix Inversion Error
    NadirResult_NadirBadFit = 13, ///< Bad Horizon Fit
    NadirResult_NadirNoDetect = 255, ///< No detection performed
} CUBEACP_NadirResult_t;

/// PowerSelect enumeration
typedef enum {
    PowerSelect_PowOff = 0, ///< Off
    PowerSelect_PowOn = 1, ///< On
    PowerSelect_PowNoChange = 2, ///< Power state kept the same
} CUBEACP_PowerSelect_t;

/// PowerSelectCubeSense enumeration
typedef enum {
    PowerSelectCubeSense_PowCsOff = 0, ///< Off
    PowerSelectCubeSense_PowCsOn = 1, ///< On
    PowerSelectCubeSense_PowCsNoChange = 2, ///< Power state kept the same
    PowerSelectCubeSense_PowCsAuto = 3, ///< Power state automatically managed
} CUBEACP_PowerSelectCubeSense_t;

/// SdLogSelect enumeration
typedef enum {
    SdLogSelect_SdLogPrimary = 0, ///< Use Primary (on-board) SD card for log file
    SdLogSelect_SdLogSecondary = 1, ///< Use Secondary SD card for log file
} CUBEACP_SdLogSelect_t;

/// SpecialConSelect enumeration
typedef enum {
    SpecialConSelect_SpecConNone = 0, ///< None
    SpecialConSelect_SpecConZSunPoint = 1, ///< Z-axis Sun pointing
    SpecialConSelect_SpecConGeoTracking = 2, ///< GEO Tracking
    SpecialConSelect_SpecConECITracking = 3, ///< Inertial pointing
    SpecialConSelect_SpecConYSunPoint = 4, ///< Y-axis Sun pointing
} CUBEACP_SpecialConSelect_t;

/// StarIDModeVal enumeration
typedef enum {
    StarIDModeVal_Tracking = 0, ///< Tracking Mode
    StarIDModeVal_Lost = 1, ///< Lost Mode
} CUBEACP_StarIDModeVal_t;

/// Stars enumeration
typedef enum {
    Stars_Zero = 0, ///< Zero
    Stars_One = 1, ///< One
    Stars_Two = 2, ///< Two
} CUBEACP_Stars_t;

/// SunResult enumeration
typedef enum {
    SunResult_SunNoError = 0, ///< No Error
    SunResult_SunTimeout = 1, ///< Camera timeout
    SunResult_SunOvercurrent = 4, ///< Sun SRAM Overcurrent detected
    SunResult_SunNotFound = 20, ///< Sun not found
    SunResult_SunNoDetect = 255, ///< No detection performed
} CUBEACP_SunResult_t;

/*******************************************************************************
 *******************************   STRUCTS   ***********************************
 ******************************************************************************/

/**
 * @brief NodeDef Information Structure
 * @details Contains NodeDef-specific Information
 */
typedef struct  {
    U8 nodeTypeId;
    U8 interfaceVersion;
} CUBEACP_NodeDefInfo_t;

/**
 * @brief ACP Execution State message structure
 * @details Returns information about the ACP loop
 */
typedef struct  {
    U16 timeSinceLoopStart;                                /**< Time since the start of the current loop iteration  (measurment unit is [ms]) */
    CUBEACP_ExecutionWaypoints_t currentExecutionPoint;    /**< Indicates which part of the loop is currently executing  */
} CUBEACP_AcpLoopState_t;

/**
 * @brief Actuator Commands message structure
 * @details Actuator commands
 */
typedef struct  {
    S16 torquerCmdX;    /**< X Magnetorquer Commanded on-time  (measurment unit is [10ms units]) */
    S16 torquerCmdY;    /**< Y Magnetorquer Commanded on-time  (measurment unit is [10ms units]) */
    S16 torquerCmdZ;    /**< Z Magnetorquer Commanded on-time  (measurment unit is [10ms units]) */
    S16 speedCmdX;      /**< X Wheel Speed  (measurment unit is [rpm]) */
    S16 speedCmdY;      /**< Y Wheel Speed  (measurment unit is [rpm]) */
    S16 speedCmdZ;      /**< Z Wheel Speed  (measurment unit is [rpm]) */
} CUBEACP_ActuatorCmd_t;

/**
 * @brief ADCS Configuration message structure
 * @details Current configuration
 */
typedef struct  {
    CUBEACP_AxisSelect_t magtorq1;               /**< Magnetorquer 1 Configuration  */
    CUBEACP_AxisSelect_t magtorq2;               /**< Magnetorquer 2 Configuration  */
    CUBEACP_AxisSelect_t magtorq3;               /**< Magnetorquer 3 Configuration  */
    CUBEACP_AxisSelect_t rW1Conf;                /**< RW1 Configuration  */
    CUBEACP_AxisSelect_t rW2Conf;                /**< RW2 Configuration  */
    CUBEACP_AxisSelect_t rW3Conf;                /**< RW3 Configuration  */
    CUBEACP_AxisSelect_t rW4Conf;                /**< RW4 or Momentum wheel Configuration  */
    CUBEACP_AxisSelect_t gyro1Conf;              /**< Gyro1 Configuration  */
    CUBEACP_AxisSelect_t gyro2Conf;              /**< Gyro2 Configuration  */
    CUBEACP_AxisSelect_t gyro3Conf;              /**< Gyro3 Configuration  */
    F64 xRateOffset;                             /**< X-Rate Sensor Offset  (measurment unit is [deg/s]) */
    F64 yRateOffset;                             /**< Y-Rate Sensor Offset  (measurment unit is [deg/s]) */
    F64 zRateOffset;                             /**< Z-Rate Sensor Offset  (measurment unit is [deg/s]) */
    U8 rateSensorMult;                           /**< Multiplier of rate sensor measurement  */
    CUBEACP_AxisSelect_t css1Conf;               /**< CSS1 Configuration  */
    CUBEACP_AxisSelect_t css2Conf;               /**< CSS2 Configuration  */
    CUBEACP_AxisSelect_t css3Conf;               /**< CSS3 Configuration  */
    CUBEACP_AxisSelect_t css4Conf;               /**< CSS4 Configuration  */
    CUBEACP_AxisSelect_t css5Conf;               /**< CSS5 Configuration  */
    CUBEACP_AxisSelect_t css6Conf;               /**< CSS6 Configuration  */
    CUBEACP_AxisSelect_t css7Conf;               /**< CSS7 Configuration  */
    CUBEACP_AxisSelect_t css8Conf;               /**< CSS8 Configuration  */
    CUBEACP_AxisSelect_t css9Conf;               /**< CSS9 Configuration  */
    CUBEACP_AxisSelect_t css10Conf;              /**< CSS10 Configuration  */
    F64 css1Scale;                               /**< CSS1 Relative Scaling Factor  */
    F64 css2Scale;                               /**< CSS2 Relative Scaling Factor  */
    F64 css3Scale;                               /**< CSS3 Relative Scaling Factor  */
    F64 css4Scale;                               /**< CSS4 Relative Scaling Factor  */
    F64 css5Scale;                               /**< CSS5 Relative Scaling Factor  */
    F64 css6Scale;                               /**< CSS6 Relative Scaling Factor  */
    F64 css7Scale;                               /**< CSS7 Relative Scaling Factor  */
    F64 css8Scale;                               /**< CSS8 Relative Scaling Factor  */
    F64 css9Scale;                               /**< CSS9 Relative Scaling Factor  */
    F64 css10Scale;                              /**< CSS10 Relative Scaling Factor  */
    U8 cssMinimum;                               /**< CSS Threshold  */
    F64 cam1Angle1;                              /**< Cam1 Sensor Mounting Transform Alpha Angle  (measurment unit is [deg]) */
    F64 cam1Angle2;                              /**< Cam1 Sensor Mounting Transform Beta Angle  (measurment unit is [deg]) */
    F64 cam1Angle3;                              /**< Cam1 Sensor Mounting Transform Gamma Angle  (measurment unit is [deg]) */
    U8 cam1Threshold;                            /**< Cam1 detection threshold  */
    Boolean cam1AutoAdj;                         /**< 0 = disabled and 1 = enabled  */
    U16 cam1Exposure;                            /**< exposure time register value  */
    F64 cam1BoreX;                               /**< X Pixel location of Cam1 boresight  (measurment unit is [pixels]) */
    F64 cam1BoreY;                               /**< Y Pixel location of Cam1 boresight  (measurment unit is [pixels]) */
    F64 cam2Angle1;                              /**< Cam2 Sensor Mounting Transform Alpha Angle  (measurment unit is [deg]) */
    F64 cam2Angle2;                              /**< Cam2 Sensor Mounting Transform Beta Angle  (measurment unit is [deg]) */
    F64 cam2Angle3;                              /**< Cam2 Sensor Mounting Transform Gamma Angle  (measurment unit is [deg]) */
    U8 cam2Threshold;                            /**< Cam2 detection threshold  */
    Boolean cam2AutoAdj;                         /**< 0 = disabled and 1 = enabled  */
    U16 cam2Exposure;                            /**< exposure time register value  */
    F64 cam2BoreX;                               /**< X Pixel location of Cam2 boresight  (measurment unit is [pixels]) */
    F64 cam2BoreY;                               /**< Y Pixel location of Cam2 boresight  (measurment unit is [pixels]) */
    U8 nadirMaxDeviationPercentage;              /**< Percentage of measured angular radius as edge's maximum allowable deviation  */
    U8 nadirMaxBadEdges;                         /**< Maximum amount of edges allowed outside maximum deviation (>50 to disable)  */
    U8 nadirMaxRadius;                           /**< Maximum Radius  (measurment unit is [°]) */
    U8 nadirMinRadius;                           /**< Minimum Radius  (measurment unit is [°]) */
    U16 cam1MaskArea1Xmin;                       /**< Cam 1 Minimum X of Area 1  */
    U16 cam1MaskArea1Xmax;                       /**< Cam 1 Maximum X of Area 1  */
    U16 cam1MaskArea1Ymin;                       /**< Cam 1 Minimum Y of Area 1  */
    U16 cam1MaskArea1Ymax;                       /**< Cam 1 Maximum Y of Area 1  */
    U16 cam1MaskArea2Xmin;                       /**< Cam 1 Minimum X of Area 2  */
    U16 cam1MaskArea2Xmax;                       /**< Cam 1 Maximum X of Area 2  */
    U16 cam1MaskArea2Ymin;                       /**< Cam 1 Minimum Y of Area 2  */
    U16 cam1MaskArea2Ymax;                       /**< Cam 1 Maximum Y of Area 2  */
    U16 cam1MaskArea3Xmin;                       /**< Cam 1 Minimum X of Area 3  */
    U16 cam1MaskArea3Xmax;                       /**< Cam 1 Maximum X of Area 3  */
    U16 cam1MaskArea3Ymin;                       /**< Cam 1 Minimum Y of Area 3  */
    U16 cam1MaskArea3Ymax;                       /**< Cam 1 Maximum Y of Area 3  */
    U16 cam1MaskArea4Xmin;                       /**< Cam 1 Minimum X of Area 4  */
    U16 cam1MaskArea4Xmax;                       /**< Cam 1 Maximum X of Area 4  */
    U16 cam1MaskArea4Ymin;                       /**< Cam 1 Minimum Y of Area 4  */
    U16 cam1MaskArea4Ymax;                       /**< Cam 1 Maximum Y of Area 4  */
    U16 cam1MaskArea5Xmin;                       /**< Cam 1 Minimum X of Area 5  */
    U16 cam1MaskArea5Xmax;                       /**< Cam 1 Maximum X of Area 5  */
    U16 cam1MaskArea5Ymin;                       /**< Cam 1 Minimum Y of Area 5  */
    U16 cam1MaskArea5Ymax;                       /**< Cam 1 Maximum Y of Area 5  */
    U16 cam2MaskArea1Xmin;                       /**< Cam 2 Minimum X of Area 1  */
    U16 cam2MaskArea1Xmax;                       /**< Cam 2 Maximum X of Area 1  */
    U16 cam2MaskArea1Ymin;                       /**< Cam 2 Minimum Y of Area 1  */
    U16 cam2MaskArea1Ymax;                       /**< Cam 2 Maximum Y of Area 1  */
    U16 cam2MaskArea2Xmin;                       /**< Cam 2 Minimum X of Area 2  */
    U16 cam2MaskArea2Xmax;                       /**< Cam 2 Maximum X of Area 2  */
    U16 cam2MaskArea2Ymin;                       /**< Cam 2 Minimum Y of Area 2  */
    U16 cam2MaskArea2Ymax;                       /**< Cam 2 Maximum Y of Area 2  */
    U16 cam2MaskArea3Xmin;                       /**< Cam 2 Minimum X of Area 3  */
    U16 cam2MaskArea3Xmax;                       /**< Cam 2 Maximum X of Area 3  */
    U16 cam2MaskArea3Ymin;                       /**< Cam 2 Minimum Y of Area 3  */
    U16 cam2MaskArea3Ymax;                       /**< Cam 2 Maximum Y of Area 3  */
    U16 cam2MaskArea4Xmin;                       /**< Cam 2 Minimum X of Area 4  */
    U16 cam2MaskArea4Xmax;                       /**< Cam 2 Maximum X of Area 4  */
    U16 cam2MaskArea4Ymin;                       /**< Cam 2 Minimum Y of Area 4  */
    U16 cam2MaskArea4Ymax;                       /**< Cam 2 Maximum Y of Area 4  */
    U16 cam2MaskArea5Xmin;                       /**< Cam 2 Minimum X of Area 5  */
    U16 cam2MaskArea5Xmax;                       /**< Cam 2 Maximum X of Area 5  */
    U16 cam2MaskArea5Ymin;                       /**< Cam 2 Minimum Y of Area 5  */
    U16 cam2MaskArea5Ymax;                       /**< Cam 2 Maximum Y of Area 5  */
    F64 magmAngle1;                              /**< Magnetometer Mounting Transform Alpha Angle  (measurment unit is [deg]) */
    F64 magmAngle2;                              /**< Magnetometer Mounting Transform Beta Angle  (measurment unit is [deg]) */
    F64 magmAngle3;                              /**< Magnetometer Mounting Transform Gamma Angle  (measurment unit is [deg]) */
    F64 magmOffset1;                             /**< Magnetometer Channel 1 Offset  */
    F64 magmOffset2;                             /**< Magnetometer Channel 2 Offset  */
    F64 magmOffset3;                             /**< Magnetometer Channel 3 Offset  */
    F64 magmSens11;                              /**< Magnetometer Sensitivity Matrix S11  */
    F64 magmSens22;                              /**< Magnetometer Sensitivity Matrix S22  */
    F64 magmSens33;                              /**< Magnetometer Sensitivity Matrix S33  */
    F64 magmSens12;                              /**< Magnetometer Sensitivity Matrix S12  */
    F64 magmSens13;                              /**< Magnetometer Sensitivity Matrix S13  */
    F64 magmSens21;                              /**< Magnetometer Sensitivity Matrix S21  */
    F64 magmSens23;                              /**< Magnetometer Sensitivity Matrix S23  */
    F64 magmSens31;                              /**< Magnetometer Sensitivity Matrix S31  */
    F64 magmSens32;                              /**< Magnetometer Sensitivity Matrix S32  */
    F64 mredAngle1;                              /**< Redundant Magnetometer Mounting Transform Alpha Angle  (measurment unit is [deg]) */
    F64 mredAngle2;                              /**< Redundant Magnetometer Mounting Transform Beta Angle  (measurment unit is [deg]) */
    F64 mredAngle3;                              /**< Redundant Magnetometer Mounting Transform Gamma Angle  (measurment unit is [deg]) */
    F64 mredOffset1;                             /**< Redundant Magnetometer Channel 1 Offset  */
    F64 mredOffset2;                             /**< Redundant Magnetometer Channel 2 Offset  */
    F64 mredOffset3;                             /**< Redundant Magnetometer Channel 3 Offset  */
    F64 mredSens11;                              /**< Redundant Magnetometer Sensitivity Matrix S11  */
    F64 mredSens22;                              /**< Redundant Magnetometer Sensitivity Matrix S22  */
    F64 mredSens33;                              /**< Redundant Magnetometer Sensitivity Matrix S33  */
    F64 mredSens12;                              /**< Redundant Magnetometer Sensitivity Matrix S12  */
    F64 mredSens13;                              /**< Redundant Magnetometer Sensitivity Matrix S13  */
    F64 mredSens21;                              /**< Redundant Magnetometer Sensitivity Matrix S21  */
    F64 mredSens23;                              /**< Redundant Magnetometer Sensitivity Matrix S23  */
    F64 mredSens31;                              /**< Redundant Magnetometer Sensitivity Matrix S31  */
    F64 mredSens32;                              /**< Redundant Magnetometer Sensitivity Matrix S32  */
    F64 starAngle1;                              /**< StarTracker Mounting Transform Alpha Angle  (measurment unit is [deg]) */
    F64 starAngle2;                              /**< StarTracker Mounting Transform Beta Angle  (measurment unit is [deg]) */
    F64 starAngle3;                              /**< StarTracker Mounting Transform Gamma Angle  (measurment unit is [deg]) */
    U16 starExposure;                            /**< exposure time register value  */
    U16 starGain;                                /**< analog gain register value  */
    U8 detectionThreshold;                       /**< StarTracker detection threshold  */
    U8 starThreshold;                            /**< StarTracker star threshold  */
    U8 maxStarMatched;                           /**< Maximum of stars that the star tracker will match  */
    U16 starTimeoutTime;                         /**< Time allowed for detection  */
    U8 maxStarPixel;                             /**< Maximum pixels in a star  */
    U8 minStarPixel;                             /**< Minimum pixels in a star  */
    F64 starErrorMargin;                         /**< % Error margin of the star identification  (measurment unit is [%]) */
    U16 starDelayTime;                           /**< Delay Time  (measurment unit is [milliseconds]) */
    F32 starCentX;                               /**< Pixel centroid X  (valid range is between -5000  and 5000 ) */
    F32 starCentY;                               /**< Pixel centroid Y  (valid range is between -5000  and 5000 ) */
    F32 starFocal;                               /**< Star Tracker Focal Length  (measurment unit is [mm]. valid range is between 5 mm and 7 mm) */
    F32 starLensK1;                              /**< First radial distortion coefficient  (measurment unit is [gain]. valid range is between -1 gain and 1 gain) */
    F32 starLensK2;                              /**< Second radial distortion coefficient  (measurment unit is [gain]. valid range is between -1 gain and 1 gain) */
    F32 starLensP1;                              /**< First tangential distortion coefficient  (measurment unit is [gain]. valid range is between -1 gain and 1 gain) */
    F32 starLensP2;                              /**< Second tangential distortion coefficients  (measurment unit is [gain]. valid range is between -1 gain and 1 gain) */
    U8 starWindowWidth;                          /**< Window width  */
    F64 starTrackingMargin;                      /**< Tracking Margin  */
    F64 starValidationMargin;                    /**< Validation Margin  */
    Boolean starModuleEnable;                    /**< Module Enable  */
    Boolean starLocationPredictionEnable;        /**< LocationPredictionEnable  */
    F64 starSearchWidth;                         /**< Search Width  */
    F32 ks;                                      /**< Detumbling Spin Gain (Ks)  (valid range is between 0  and 10000 ) */
    F32 kd;                                      /**< Detumbling Damping Gain (Kd)  (valid range is between 0  and 10000 ) */
    F64 wy_ref;                                  /**< Reference spin rate (wy-ref). Must always be smaller than 0 for Y-spin  (measurment unit is [deg/s]. valid range is between -32000 deg/s and 32000 deg/s) */
    F32 kdf;                                     /**< Fast BDot Detumbling Gain (Kdf)  (valid range is between 0  and 100 ) */
    F32 kh;                                      /**< Y-Momentum Control Gain (Kh)  (valid range is between 0  and 10000 ) */
    F32 kn;                                      /**< Y-momentum Nutation Damping Gain (Kn)  (valid range is between 0  and 10000 ) */
    F32 kp1;                                     /**< Y-momentum Proportional Gain (Kp1)  (valid range is between 0  and 100 ) */
    F32 kd1;                                     /**< Y-momentum Derivative Gain (Kd1)  (valid range is between 0  and 100 ) */
    F32 h_ref;                                   /**< Reference Wheel Momentum (H-ref). Must always be smaller than 0  (measurment unit is [Nms]. valid range is between -10 Nms and 0 Nms) */
    F32 kp2;                                     /**< RWheel Proportional Gain (Kp2)  (valid range is between 0  and 100 ) */
    F32 kd2;                                     /**< RWheel Derivative Gain (Kd2)  (valid range is between 0  and 100 ) */
    F32 h_bias;                                  /**< Y-Wheel Bias Momentum (H-bias)  (measurment unit is [Nms]. valid range is between -10 Nms and 10 Nms) */
    CUBEACP_AxisSelect_t sunPointFacet;          /**< Satellite body axis that will align with sun vector  */
    Boolean wheelErrorHandling;                  /**< Enable/disable automatic transition from wheel control modes to Y-Thomson mode in case of wheel error  */
    F32 kp3;                                     /**< Tracking Proportional Gain (Kp3)  (valid range is between 0  and 100 ) */
    F32 kd3;                                     /**< Tracking Derivative Gain (Kd3)  (valid range is between 0  and 100 ) */
    F32 ki3;                                     /**< Tracking Integral Gain (Ki3)  (valid range is between 0  and 100 ) */
    CUBEACP_AxisSelect_t targetTrackFacet;       /**< Satellite body axis that will point to target  */
    F32 ixx;                                     /**< Moment Of Inertia - Ixx  (measurment unit is [kg.m^2]. valid range is between 0 kg.m^2 and 10 kg.m^2) */
    F32 iyy;                                     /**< Moment Of Inertia - Iyy  (measurment unit is [kg.m^2]. valid range is between 0 kg.m^2 and 10 kg.m^2) */
    F32 izz;                                     /**< Moment Of Inertia - Izz  (measurment unit is [kg.m^2]. valid range is between 0 kg.m^2 and 10 kg.m^2) */
    F32 ixy;                                     /**< Product Of Inertia - Ixy  (measurment unit is [kg.m^2]. valid range is between -10 kg.m^2 and 10 kg.m^2) */
    F32 ixz;                                     /**< Product Of Inertia - Ixz  (measurment unit is [kg.m^2]. valid range is between -10 kg.m^2 and 10 kg.m^2) */
    F32 iyz;                                     /**< Product Of Inertia - Iyz  (measurment unit is [kg.m^2]. valid range is between -10 kg.m^2 and 10 kg.m^2) */
    F32 magRateNoise;                            /**< Magnetometer Rate Filter System Noise  (valid range is between 0  and 100 ) */
    F32 ekfSysNoise;                             /**< EKF System Noise  (valid range is between 0  and 100 ) */
    F32 cssNoise;                                /**< CSS Measurement Noise  (valid range is between 0  and 100 ) */
    F32 sunNoise;                                /**< Sun Sensor Measurement Noise  (valid range is between 0  and 100 ) */
    F32 nadirNoise;                              /**< Nadir Sensor Measurement Noise  (valid range is between 0  and 100 ) */
    F32 magNoise;                                /**< Magnetometer Measurement Noise  (valid range is between 0  and 100 ) */
    F32 starNoise;                               /**< Star Tracker Measurement Noise  (valid range is between 0  and 100 ) */
    Boolean useSunEst;                           /**< Use Sun Sensor measurement in EKF  */
    Boolean useNadirEst;                         /**< Use Nadir Sensor measurement in EKF  */
    Boolean useCssEst;                           /**< Use CSS measurement in EKF  */
    Boolean useStarEst;                          /**< Use Star Tracker measurement in EKF  */
    Boolean terminatorCheck;                     /**< Select to ignore Nadir sensor measurements when terminator is in FOV  */
    Boolean autoRecoverMtm;                      /**< Select whether automatic switch to redundant magnetometer should occur in case of failure  */
    CUBEACP_MagModeVal_t magMode;                /**< Mode describing which magnetometer is used for estimation and control  */
    CUBEACP_MagModeVal_t magRawTlm2Selection;    /**< Select which magnetometer and sampling to use for 2nd raw magnetometer tlm frame  */
    Boolean rateSensorErrorHandling;             /**< Enable/disable automatic transition from MEMS rate estimation mode to RKF in case of rate sensor error  */
    Boolean wheelPowerOn30sDelay;                /**< Delay wheel communications for 30s after power-cycle  */
    U8 cam1Cam2Period;                           /**< Cam1 and Cam2 sensor sampling period. Lower four bits are Cam1 period and upper four bits the Cam2 period. Setting period to zero for sensor will disable sampling of sensor.  (measurment unit is [s]) */
    F64 aInclCoeff;                              /**< Inclination filter coefficient  */
    F64 aRaanCoeff;                              /**< RAAN filter coefficient  */
    F64 aEccCoeff;                               /**< Eccentricity filter coefficient  */
    F64 aArgPerCoeff;                            /**< Argument of perigee filter coefficient  */
    F64 aTimeCoeff;                              /**< Time filter coefficient  */
    F64 aPosCoeff;                               /**< Position filter coefficient  */
    F64 asgp4MaxPosError;                        /**< Maximum position error for asgp4 to continue working  */
    CUBEACP_AsgpFilter_t asgp4Filter;            /**< The type of filter asgp4 is using  */
    F64 asgp4Xp;                                 /**< Polar coefficient xp  */
    F64 asgp4Yp;                                 /**< Polar coefficient yp  */
    U8 asgp4GpsRollover;                         /**< GPS roll over number  */
    F64 asgp4PosSdTh;                            /**< Maximum position standard deviation for asgp4 to operate  */
    F64 asgp4VelSdTh;                            /**< Maximum velocity standard deviation for asgp4 to operate  */
    U8 asgp4MinSat;                              /**< Minimum satellites for asgp4 to operate  */
    F64 asgp4TimeGain;                           /**< Time offset compensation gain  */
    F64 asgp4MaxLag;                             /**< Maximum lagged timestamp measurements to incorporate  */
    U16 asgp4MinSamples;                         /**< Minimum samples to use for asgp4 process  */
    U8 userConSettings[48];                      /**< Settings for user coded control mode(s)  */
    U8 userEstSettings[48];                      /**< Settings for user coded estimation mode(s)  */
} CUBEACP_AdcsConfig_t;

/**
 * @brief Adcs Execution Times message structure
 * @details Returns information about execution times of ACP functions
 */
typedef struct  {
    U16 timeAdcsUpdate;             /**< Time to perform complete ADCS Update function  (measurment unit is [ms]) */
    U16 timeSensorActuatorComms;    /**< Time to perform Sensor/actuator communications  (measurment unit is [ms]) */
    U16 timeSgp4;                   /**< Time to execute SGP4 propagator  (measurment unit is [ms]) */
    U16 timeIgrf;                   /**< Time to execute IGRF computation  (measurment unit is [ms]) */
} CUBEACP_AdcsExecTimes_t;

/**
 * @brief ADCS Measurements message structure
 * @details Calibrated sensor measurements
 */
typedef struct  {
    F64 magX;       /**< Magnetic Field X  (measurment unit is [uT]) */
    F64 magY;       /**< Magnetic Field Y  (measurment unit is [uT]) */
    F64 magZ;       /**< Magnetic Field Z  (measurment unit is [uT]) */
    F64 cssX;       /**< Coarse Sun X  */
    F64 cssY;       /**< Coarse Sun Y  */
    F64 cssZ;       /**< Coarse Sun Z  */
    F64 sunX;       /**< Sun X  */
    F64 sunY;       /**< Sun Y  */
    F64 sunZ;       /**< Sun Z  */
    F64 nadirX;     /**< Nadir X  */
    F64 nadirY;     /**< Nadir Y  */
    F64 nadirZ;     /**< Nadir Z  */
    F64 rateX;      /**< X Angular Rate  (measurment unit is [deg/s]) */
    F64 rateY;      /**< Y Angular Rate  (measurment unit is [deg/s]) */
    F64 rateZ;      /**< Z Angular Rate  (measurment unit is [deg/s]) */
    S16 speedX;     /**< X Wheel Speed  (measurment unit is [rpm]) */
    S16 speedY;     /**< Y Wheel Speed  (measurment unit is [rpm]) */
    S16 speedZ;     /**< Z Wheel Speed  (measurment unit is [rpm]) */
    F64 star1BX;    /**< Star1 body X-vector  */
    F64 star1BY;    /**< Star1 body Y-vector  */
    F64 star1BZ;    /**< Star1 body Z-vector  */
    F64 star1OX;    /**< Star1 orbit X-vector  */
    F64 star1OY;    /**< Star1 orbit Y-vector  */
    F64 star1OZ;    /**< Star1 orbit Z-vector  */
    F64 star2BX;    /**< Star2 body X-vector  */
    F64 star2BY;    /**< Star2 body Y-vector  */
    F64 star2BZ;    /**< Star2 body Z-vector  */
    F64 star2OX;    /**< Star2 orbit X-vector  */
    F64 star2OY;    /**< Star2 orbit Y-vector  */
    F64 star2OZ;    /**< Star2 orbit Z-vector  */
    F64 star3BX;    /**< Star3 body X-vector  */
    F64 star3BY;    /**< Star3 body Y-vector  */
    F64 star3BZ;    /**< Star3 body Z-vector  */
    F64 star3OX;    /**< Star3 orbit X-vector  */
    F64 star3OY;    /**< Star3 orbit Y-vector  */
    F64 star3OZ;    /**< Star3 orbit Z-vector  */
} CUBEACP_AdcsMeasure_t;

/**
 * @brief ADCS Power Control message structure
 * @details Control power to selected components
 */
typedef struct  {
    CUBEACP_PowerSelect_t cubeControlSignalPower;      /**< Control power to electronics of CubeControl Signal PIC  */
    CUBEACP_PowerSelect_t cubeControlMotorPower;       /**< Control power to electronics of CubeControl Motor PIC  */
    CUBEACP_PowerSelectCubeSense_t cubeSense1Power;    /**< Control power to the CubeSense1  */
    CUBEACP_PowerSelectCubeSense_t cubeSense2Power;    /**< Control power to the CubeSense2  */
    CUBEACP_PowerSelect_t cubeStarPower;               /**< Control power to the CubeStar  */
    CUBEACP_PowerSelect_t cubeWheel1Power;             /**< Control power to the CubeWheel1  */
    CUBEACP_PowerSelect_t cubeWheel2Power;             /**< Control power to the CubeWheel2  */
    CUBEACP_PowerSelect_t cubeWheel3Power;             /**< Control power to the CubeWheel3  */
    CUBEACP_PowerSelect_t motorPower;                  /**< Control power to Motor electronics  */
    CUBEACP_PowerSelect_t gpsLnaPower;                 /**< Control power to GPS LNA  */
} CUBEACP_AdcsPower_t;

/**
 * @brief Power and Temperature Measurements message structure
 * @details Power and temperature measurements
 */
typedef struct  {
    F64 cubeSense1_3V3Current;        /**< CubeSense1 3V3 Current  (measurment unit is [mA]) */
    F64 cubeSense1_CamCurrent;        /**< CubeSense1 Cam SRAM Current  (measurment unit is [mA]) */
    F64 cubeSense2_3V3Current;        /**< CubeSense2 3V3 Current  (measurment unit is [mA]) */
    F64 cubeSense2_CamCurrent;        /**< CubeSense2 Cam SRAM Current  (measurment unit is [mA]) */
    F64 cubeControl3V3Current;        /**< CubeControl 3V3 Current  (measurment unit is [mA]) */
    F64 cubeControl5VCurrent;         /**< CubeControl 5V Current  (measurment unit is [mA]) */
    F64 cubeControlBatCurrent;        /**< CubeControl Vbat Current  (measurment unit is [mA]) */
    F64 wheel1Current;                /**< Wheel1 Current  (measurment unit is [mA]) */
    F64 wheel2Current;                /**< Wheel2 Current  (measurment unit is [mA]) */
    F64 wheel3Current;                /**< Wheel3 Current  (measurment unit is [mA]) */
    F64 cubeStarCurrent;              /**< CubeStar Current  (measurment unit is [mA]) */
    F64 magtorqCurrent;               /**< Magnetorquer Current  (measurment unit is [mA]) */
    F64 cubeStarTemp;                 /**< CubeStar MCU temperature  (measurment unit is [C]) */
    S16 mCUTemp;                      /**< MCU Temperature  (measurment unit is [C]) */
    F64 magnetometerTemp;             /**< Magnetometer Temperature  (measurment unit is [C]) */
    F64 redundentMagnetometerTemp;    /**< Redundant Magnetometer Temperature  (measurment unit is [C]) */
    S16 xRateTemp;                    /**< X-Rate sensor Temperature  (measurment unit is [C]) */
    S16 yRateTemp;                    /**< Y-Rate sensor Temperature  (measurment unit is [C]) */
    S16 zRateTemp;                    /**< Z-Rate sensor Temperature  (measurment unit is [C]) */
} CUBEACP_AdcsPowerMeasure_t;

/**
 * @brief ADCS State message structure
 * @details Current ADCS state
 */
typedef struct  {
    CUBEACP_EstimModeSelect_t estimMode;      /**< Current attitude estimation mode  */
    CUBEACP_ConModeSelect_t controlMode;      /**< Current attitude control mode  */
    CUBEACP_AdcsRunMode_t adcsRunMode;        /**< Current ADCS Running mode  */
    CUBEACP_Asgp4ModeSelect_t asgp4Mode;      /**< ASGP4 enabled state  */
    Boolean cubeControlSignalPower;           /**< CubeControl Signal electronics enabled status  */
    Boolean cubeControlMotorPower;            /**< CubeControl Motor electronics enabled status  */
    Boolean cubeSense1Power;                  /**< CubeSense1 enabled status  */
    Boolean cubeSense2Power;                  /**< CubeSense2 enabled status  */
    Boolean cubeWheel1Power;                  /**< CubeWheel1 enabled status  */
    Boolean cubeWheel2Power;                  /**< CubeWheel2 enabled status  */
    Boolean cubeWheel3Power;                  /**< CubeWheel3 enabled status  */
    Boolean cubeStarPower;                    /**< CubeStar enabled status  */
    Boolean gpsReceiverPower;                 /**< GPS Receiver enabled status  */
    Boolean gpsLnaPower;                      /**< GPS Antenna LNA enabled status  */
    Boolean motorDriverPower;                 /**< Motor Driver Electronics enabled status  */
    Boolean sunAboveHorizon;                  /**< Sun is above the local horizon (elevation > 0)  */
    Boolean cubeSense1CommsError;             /**< Communication error occurred with the CubeSense1  */
    Boolean cubeSense2CommsError;             /**< Communication error occurred with the CubeSense2  */
    Boolean cubeControlSignalCommsError;      /**< Communication error occurred with the CubeControl Signal MCU  */
    Boolean cubeControlMotorCommsError;       /**< Communication error occurred with the CubeControl Motor MCU  */
    Boolean cubeWheel1CommsError;             /**< Communication error occurred with the CubeWheel1  */
    Boolean cubeWheel2CommsError;             /**< Communication error occurred with the CubeWheel2  */
    Boolean cubeWheel3CommsError;             /**< Communication error occurred with the CubeWheel3  */
    Boolean cubeStarCommsError;               /**< Communication error occurred with the CubeStar  */
    Boolean magRangeError;                    /**< Magnetometer measured magnetic field with size <15 uT or >65 uT  */
    Boolean cam1OvercurrentSram;              /**< Cam1 SRAM overcurrent detected  */
    Boolean cam1Overcurrent3V3;               /**< Cam1 3V3 overcurrent detected  */
    Boolean cam1SensNotIdle;                  /**< Cam1 sensor was not idle at the start of ADCS loop  */
    Boolean cam1SensDetectError;              /**< Cam1 sensor was unable to compute angles (could be not in FOV)  */
    Boolean sunSensRangeError;                /**< Detected sun angles were outside of +/- 90 deg  */
    Boolean cam2OvercurrentSram;              /**< Cam2 SRAM overcurrent detected  */
    Boolean cam2Overcurrent3V3;               /**< Cam2 3V3 overcurrent detected  */
    Boolean cam2SensNotIdle;                  /**< Cam2 sensor was not idle at the start of ADCS loop  */
    Boolean cam2SensDetectError;              /**< Cam2 sensor was unable to compute angles (could be not in FOV)  */
    Boolean nadirSensRangeError;              /**< Detected nadir angles were outside of +/- 60 deg  */
    Boolean rateSensRangeError;               /**< Measured XYZ-body rate is outside of the range +/-20 deg/s  */
    Boolean wheelSpeedRangeError;             /**< Wheel XYZ speed measurement was outside the range +/-8500 rpm  */
    Boolean cssError;                         /**< Unable to compute Coarse Sun vector (could be not in FOV)  */
    Boolean starMatchError;                   /**< Unable to obtain enough matched stars  */
    Boolean starTrackOvercurrent;             /**< Star tracker overcurrent detected  */
    Boolean orbitParamsInvalidError;          /**< Orbit Parameters are not in allowed bounds (angle exceeding limits etc.). Failed to initialize SGP4 propagator using supplied parameters  */
    Boolean configInvalidError;               /**< Magnetorquer Configuration or CSS in invalid. Each principle axis should have a torquer output (1,2, or 3) assigned. At least one CSS per principle axis needed  */
    Boolean controlModeNotAllowed;            /**< Attempt was made to select control mode without appropriate estimator, or command to set Y-momentum mode while not in steady-state Y-Thomson  */
    Boolean estimatorNotAllowed;              /**< Attempt was made to change to an estimation mode that would be inappropriate for the current control mode  */
    CUBEACP_MagModeVal_t curMagMode;          /**< Current magnetometer sampling mode  */
    Boolean magfieldModelError;               /**< Modelled and measured magnetic field differs in size by more than 5000 nT  */
    Boolean nodeRecoveryError;                /**< Failed to Recover an ADCS Node by successive resets  */
    Boolean cubeSense1RuntimeError;           /**< Runtime error occurred with the CubeSense1  */
    Boolean cubeSense2RuntimeError;           /**< Runtime error occurred with the CubeSense2  */
    Boolean cubeControlSignalRuntimeError;    /**< Runtime error occurred with the CubeControl Signal MCU  */
    Boolean cubeControlMotorRuntimeError;     /**< Runtime error occurred with the CubeControl Motor MCU  */
    Boolean cubeWheel1RuntimeError;           /**< Runtime error occurred with the CubeWheel1  */
    Boolean cubeWheel2RuntimeError;           /**< Runtime error occurred with the CubeWheel2  */
    Boolean cubeWheel3RuntimeError;           /**< Runtime error occurred with the CubeWheel3  */
    Boolean cubeStarRuntimeError;             /**< Runtime error occurred with the CubeStar  */
    Boolean magnetometerError;                /**< Magnetometer failure occurred  */
    Boolean rateSensorFailure;                /**< Rate sensor failure occurred  */
    F64 roll;                                 /**< Estimated roll angle  (measurment unit is [deg]) */
    F64 pitch;                                /**< Estimated pitch angle  (measurment unit is [deg]) */
    F64 yaw;                                  /**< Estimated yaw angle  (measurment unit is [deg]) */
    S16 q1;                                   /**< Estimated q1  */
    S16 q2;                                   /**< Estimated q2  */
    S16 q3;                                   /**< Estimated q3  */
    F64 rateX;                                /**< Estimated X angular rate  (measurment unit is [deg/s]) */
    F64 rateY;                                /**< Estimated Y angular rate  (measurment unit is [deg/s]) */
    F64 rateZ;                                /**< Estimated Z angular rate  (measurment unit is [deg/s]) */
    F64 positionX;                            /**< ECI referenced X coordinate  (measurment unit is [km]) */
    F64 positionY;                            /**< ECI referenced Y coordinate  (measurment unit is [km]) */
    F64 positionZ;                            /**< ECI referenced Z coordinate  (measurment unit is [km]) */
    F64 velocityX;                            /**< ECI referenced X velocity  (measurment unit is [m/s]) */
    F64 velocityY;                            /**< ECI referenced Y velocity  (measurment unit is [m/s]) */
    F64 velocityZ;                            /**< ECI referenced Z velocity  (measurment unit is [m/s]) */
    F64 latitude;                             /**< WGS-84 Latitude angle  (measurment unit is [deg]) */
    F64 longitude;                            /**< Longitude angle  (measurment unit is [deg]) */
    F64 altitude;                             /**< WGS-84 altitude  (measurment unit is [km]) */
    S16 posEcefX;                             /**< ECEF Position X  (measurment unit is [m]) */
    S16 posEcefY;                             /**< ECEF Position Y  (measurment unit is [m]) */
    S16 posEcefZ;                             /**< ECEF Position Z  (measurment unit is [m]) */
} CUBEACP_AdcsState_t;

/**
 * @brief ADCS System Configuration message structure
 * @details Current hard-coded system configuration
 */
typedef struct  {
    CUBEACP_AcpProgramType_t acpType;             /**< ACP Type  */
    CUBEACP_SpecialConSelect_t specialControl;    /**< Special Control Selection  */
    U8 ccSignalVer;                               /**< CubeControl Signal Version  */
    U8 ccMotorVer;                                /**< CubeControl Motor Version  */
    U8 cs1Ver;                                    /**< CubeSense1 Version  */
    U8 cs2Ver;                                    /**< CubeSense2 Version  */
    CUBEACP_CsCamType_t csCam1Type;               /**< CubeSense1 Camera Type  */
    CUBEACP_CsCamType_t csCam2Type;               /**< CubeSense2 Camera Type  */
    U8 cubeStarVer;                               /**< CubeStar Version  */
    CUBEACP_GpsSelect_t gpsType;                  /**< GPS Type  */
    Boolean hasRedMag;                            /**< Redundant MTM Included  */
    F32 mqx;                                      /**< Magnetorquer-X Max Dipole  (measurment unit is [A.m^2]. valid range is between 0 A.m^2 and 2 A.m^2) */
    F32 mqy;                                      /**< Magnetorquer-Y Max Dipole  (measurment unit is [A.m^2]. valid range is between 0 A.m^2 and 2 A.m^2) */
    F32 mqz;                                      /**< Magnetorquer-Z Max Dipole  (measurment unit is [A.m^2]. valid range is between 0 A.m^2 and 2 A.m^2) */
    F32 mtTmin;                                   /**< Magnetorquer On-time Resolution  (measurment unit is [s]. valid range is between 0 s and 1 s) */
    F32 mtTmax;                                   /**< Magnetorquer Maximum On-time  (measurment unit is [s]. valid range is between 0 s and 1 s) */
    F32 nSatX;                                    /**< RW-X Maximum Torque  (measurment unit is [N.m]. valid range is between 0 N.m and 0.1 N.m) */
    F32 nSatY;                                    /**< RW-Y Maximum Torque  (measurment unit is [N.m]. valid range is between 0 N.m and 0.1 N.m) */
    F32 nSatZ;                                    /**< RW-Z Maximum Torque  (measurment unit is [N.m]. valid range is between 0 N.m and 0.1 N.m) */
    F32 hSatX;                                    /**< RW-X Maximum Momentum  (measurment unit is [Nms]. valid range is between 0 Nms and 0.1 Nms) */
    F32 hSatY;                                    /**< RW-Y Maximum Momentum  (measurment unit is [Nms]. valid range is between 0 Nms and 0.1 Nms) */
    F32 hSatZ;                                    /**< RW-Z Maximum Momentum  (measurment unit is [Nms]. valid range is between 0 Nms and 0.1 Nms) */
    F32 iwx;                                      /**< RW-X Inertia  (measurment unit is [kg.m^2]. valid range is between 0 kg.m^2 and 0.001 kg.m^2) */
    F32 iwy;                                      /**< RW-Y Inertia  (measurment unit is [kg.m^2]. valid range is between 0 kg.m^2 and 0.001 kg.m^2) */
    F32 iwz;                                      /**< RW-Z Inertia  (measurment unit is [kg.m^2]. valid range is between 0 kg.m^2 and 0.001 kg.m^2) */
    F32 ndel;                                     /**< RW Torque Increment  (measurment unit is [N.m]. valid range is between 0 N.m and 0.1 N.m) */
    F32 biasX_d1;                                 /**< Primary MTM X-Bias d1  (valid range is between -10  and 10 ) */
    F32 biasY_d1;                                 /**< Primary MTM Y-Bias d1  (valid range is between -10  and 10 ) */
    F32 biasZ_d1;                                 /**< Primary MTM Z-Bias d1  (valid range is between -10  and 10 ) */
    F32 biasX_d2;                                 /**< Primary MTM X-Bias d2  (valid range is between -10000  and 10000 ) */
    F32 biasY_d2;                                 /**< Primary MTM Y-Bias d2  (valid range is between -10000  and 10000 ) */
    F32 biasZ_d2;                                 /**< Primary MTM Z-Bias d2  (valid range is between -10000  and 10000 ) */
    F32 sensX_s1;                                 /**< Primary MTM X-Sens s1  (valid range is between -1  and 1 ) */
    F32 sensY_s1;                                 /**< Primary MTM Y-Sens s1  (valid range is between -1  and 1 ) */
    F32 sensZ_s1;                                 /**< Primary MTM Z-Sens s1  (valid range is between -1  and 1 ) */
    F32 sensX_s2;                                 /**< Primary MTM X-Sens s2  (valid range is between -10  and 10 ) */
    F32 sensY_s2;                                 /**< Primary MTM Y-Sens s2  (valid range is between -10  and 10 ) */
    F32 sensZ_s2;                                 /**< Primary MTM Z-Sens s2  (valid range is between -10  and 10 ) */
    F32 red_BiasX_d1;                             /**< Redundant MTM X-Bias d1  (valid range is between -10  and 10 ) */
    F32 red_BiasY_d1;                             /**< Redundant MTM Y-Bias d1  (valid range is between -10  and 10 ) */
    F32 red_BiasZ_d1;                             /**< Redundant MTM Z-Bias d1  (valid range is between -10  and 10 ) */
    F32 red_BiasX_d2;                             /**< Redundant MTM X-Bias d2  (valid range is between -10000  and 10000 ) */
    F32 red_BiasY_d2;                             /**< Redundant MTM Y-Bias d2  (valid range is between -10000  and 10000 ) */
    F32 red_BiasZ_d2;                             /**< Redundant MTM Z-Bias d2  (valid range is between -10000  and 10000 ) */
    F32 red_SensX_s1;                             /**< Redundant MTM X-Sens s1  (valid range is between -1  and 1 ) */
    F32 red_SensY_s1;                             /**< Redundant MTM Y-Sens s1  (valid range is between -1  and 1 ) */
    F32 red_SensZ_s1;                             /**< Redundant MTM Z-Sens s1  (valid range is between -1  and 1 ) */
    F32 red_SensX_s2;                             /**< Redundant MTM X-Sens s2  (valid range is between -10  and 10 ) */
    F32 red_SensY_s2;                             /**< Redundant MTM Y-Sens s2  (valid range is between -10  and 10 ) */
    F32 red_SensZ_s2;                             /**< Redundant MTM Z-Sens s2  (valid range is between -10  and 10 ) */
    CUBEACP_GpioPort_t ccsEnablePort;             /**< CC Signal Enable GPIO port  */
    CUBEACP_GpioPortPin_t ccsEnablePin;           /**< CC Signal Enable GPIO port pin  */
    CUBEACP_GpioPort_t ccmEnablePort;             /**< CC Motor Enable GPIO port  */
    CUBEACP_GpioPortPin_t ccmEnablePin;           /**< CC Motor Enable GPIO port pin  */
    CUBEACP_GpioPort_t cccEnablePort;             /**< CC Common Enable GPIO port  */
    CUBEACP_GpioPortPin_t cccEnablePin;           /**< CC Common Enable GPIO port pin  */
    CUBEACP_GpioPort_t cSense1EnablePort;         /**< CubeSense1 Enable GPIO port  */
    CUBEACP_GpioPortPin_t cSense1EnablePin;       /**< CubeSense1 Enable GPIO port pin  */
    CUBEACP_GpioPort_t cSense2EnablePort;         /**< CubeSense2 Enable GPIO port  */
    CUBEACP_GpioPortPin_t cSense2EnablePin;       /**< CubeSense2 Enable GPIO port pin  */
    CUBEACP_GpioPort_t cStarEnablePort;           /**< CubeStar Enable GPIO port  */
    CUBEACP_GpioPortPin_t cStarEnablePin;         /**< CubeStar Enable GPIO port pin  */
    CUBEACP_GpioPort_t cW1EnablePort;             /**< CubeWheel1 Enable GPIO port  */
    CUBEACP_GpioPortPin_t cW1EnablePin;           /**< CubeWheel1 Enable GPIO port pin  */
    CUBEACP_GpioPort_t cW2EnablePort;             /**< CubeWheel2 Enable GPIO port  */
    CUBEACP_GpioPortPin_t cW2EnablePin;           /**< CubeWheel2 Enable GPIO port pin  */
    CUBEACP_GpioPort_t cW3EnablePort;             /**< CubeWheel3 Enable GPIO port  */
    CUBEACP_GpioPortPin_t cW3EnablePin;           /**< CubeWheel3 Enable GPIO port pin  */
} CUBEACP_AdcsSystemConfig_t;

/**
 * @brief ASGP4 TLEs message structure
 * @details ASGP4 TLEs generated
 */
typedef struct  {
    Boolean asgp4Complete;           /**< Is ASGP4 process complete  */
    CUBEACP_Asgp4Error_t asgpErr;    /**< The error state that the asgp4 module is in  */
    F32 asgp4Epoch;                  /**< Epoch from asgp4  */
    F32 asgp4Incli;                  /**< Inclination from asgp4  */
    F32 asgp4Raan;                   /**< RAAN from asgp4  */
    F32 asgp4Ecc;                    /**< Eccentricity from asgp4  */
    F32 asgp4Aop;                    /**< AOP from asgp4  */
    F32 asgp4Ma;                     /**< MA from asgp4  */
    F32 asgp4Mm;                     /**< MM from asgp4  */
    F32 asgp4Bstar;                  /**< BStar from asgp4  */
} CUBEACP_Asgp4KepTle_t;

/**
 * @brief Clear Errors message structure
 * @details Clear Latched Error Flags
 */
typedef struct  {
    Boolean aDCSErrors;    /**< Clear ADCS error flags  */
    Boolean hKErrors;      /**< Clear HK Error flags  */
} CUBEACP_ClearErrors_t;

/**
 * @brief Commanded Attitude Angles message structure
 * @details Commanded attitude angles
 */
typedef struct  {
    F64 roll;     /**< Commanded roll angle  (measurment unit is [deg]. valid range is between -9000 deg and 9000 deg) */
    F64 pitch;    /**< Commanded pitch angle  (measurment unit is [deg]. valid range is between -18000 deg and 18000 deg) */
    F64 yaw;      /**< Commanded yaw angle  (measurment unit is [deg]. valid range is between -18000 deg and 18000 deg) */
} CUBEACP_CmdAttitude_t;

/**
 * @brief Tracking Controller Target Reference message structure
 * @details Target reference for tracking control mode
 */
typedef struct  {
    F32 longRef;    /**< Geocentric longitude of target  (measurment unit is [deg]. valid range is between 0 deg and 360 deg) */
    F32 latRef;     /**< Geocentric latitude of target  (measurment unit is [deg]. valid range is between -90 deg and 90 deg) */
    F32 altRef;     /**< Geocentric altitude of target  (measurment unit is [meter]. valid range is between -20000 meter and 40000000 meter) */
} CUBEACP_CmdTrackingTarget_t;

/**
 * @brief Set Attitude Control Mode message structure
 * @details Set attitude control mode
 */
typedef struct  {
    CUBEACP_ConModeSelect_t controlModeSelection;    /**< Attitude control mode  */
    U16 timeout;                                     /**< Control timeout duration. Control will revert to None when timer reaches zero. 0xFFFF for infinite timeout  (measurment unit is [s]) */
} CUBEACP_ControlMode_t;

/**
 * @brief JPG Conversion Progress message structure
 * @details Conversion progress
 */
typedef struct  {
    U8 progress;                                    /**< Progress %  */
    CUBEACP_JpgConvertResult_t conversionResult;    /**< JPG Conversion Result  */
    U8 outFileCounter;                              /**< Output File Counter  */
} CUBEACP_ConversionProgress_t;

/**
 * @brief Convert to JPG file message structure
 * @details Convert raw or bmp files to JPG
 */
typedef struct  {
    U8 srcFileCtr;       /**< Source File Counter  */
    U8 qualityFactor;    /**< Quality Factor  */
    U8 whiteBalance;     /**< White Balance  */
} CUBEACP_Convert_t;

/**
 * @brief CubeACP State message structure
 * @details Contains flags regarding the state of the ACP
 */
typedef struct  {
    Boolean adcsConfigLoadError;      /**< Flag to indicate that the ADCS configuartion was not read successfully out of flash  */
    Boolean orbitParamsLoadError;     /**< Flag to indicate that the Orbit parameters were not read successfully out of flash  */
    Boolean systemConfigLoadError;    /**< Flag to indicate that the System Configuration was not read successfully out of flash  */
    Boolean sdInitError;              /**< Flag to indicate that the SD card failed to initialise  */
    Boolean sdReadError;              /**< Flag to indicate that a read operation from the SD card failed  */
    Boolean sdWriteError;             /**< Flag to indicate that a write operation to the SD card failed  */
} CUBEACP_CubeACPState_t;

/**
 * @brief Estimation Data message structure
 * @details Estimation meta-data
 */
typedef struct  {
    F64 igrfMagX;          /**< IGRF Modelled Magnetic Field X  (measurment unit is [uT]) */
    F64 igrfMagY;          /**< IGRF Modelled Magnetic Field Y  (measurment unit is [uT]) */
    F64 igrfMagZ;          /**< IGRF Modelled Magnetic Field Z  (measurment unit is [uT]) */
    F64 modelSunX;         /**< Modelled Sun Vector X  */
    F64 modelSunY;         /**< Modelled Sun Vector Y  */
    F64 modelSunZ;         /**< Modelled Sun Vector Z  */
    F64 estimGyroBiasX;    /**< Estimated X-gyro Bias  (measurment unit is [deg/s]) */
    F64 estimGyroBiasY;    /**< Estimated Y-gyro Bias  (measurment unit is [deg/s]) */
    F64 estimGyroBiasZ;    /**< Estimated Z-gyro Bias  (measurment unit is [deg/s]) */
    F64 innovX;            /**< Innovation Vector X  */
    F64 innovY;            /**< Innovation Vector Y  */
    F64 innovZ;            /**< Innovation Vector Z  */
    F64 qError1;           /**< Quaternion Error - Q1  */
    F64 qError2;           /**< Quaternion Error - Q2  */
    F64 qError3;           /**< Quaternion Error - Q3  */
    F64 qCovar1;           /**< Quaternion Covariance - Q1 RMS  */
    F64 qCovar2;           /**< Quaternion Covariance - Q2 RMS  */
    F64 qCovar3;           /**< Quaternion Covariance - Q3 RMS  */
    F64 rateCovarX;        /**< X Angular Rate Covariance  */
    F64 rateCovarY;        /**< Y Angular Rate Covariance  */
    F64 rateCovarZ;        /**< Z Angular Rate Covariance  */
} CUBEACP_EstimData_t;

/**
 * @brief Fine Estimated Angular Rates message structure
 * @details High resolution estimated angular rates relative to orbit reference frame
 */
typedef struct  {
    F64 rateX;    /**< Estimated X angular rate  (measurment unit is [deg/s]) */
    F64 rateY;    /**< Estimated Y angular rate  (measurment unit is [deg/s]) */
    F64 rateZ;    /**< Estimated Z angular rate  (measurment unit is [deg/s]) */
} CUBEACP_FineEstimRates_t;

/**
 * @brief Status of Image Capture and Save Operation message structure
 * @details Status of Image Capture and Save Operation
 */
typedef struct  {
    U8 percentageComplete;            /**< Current progress of operation  (measurment unit is [%]) */
    CUBEACP_ImSaveStatus_t status;    /**< Current status of operation  */
} CUBEACP_ImageSaveStatus_t;

/**
 * @brief Inertial Pointing Reference Vector message structure
 * @details Reference unit vector for inertial pointing control mode
 */
typedef struct  {
    F64 inertialRefX;    /**< Inertial Reference X  */
    F64 inertialRefY;    /**< Inertial Reference Y  */
    F64 inertialRefZ;    /**< Inertial Reference Z  */
} CUBEACP_InertialPointReference_t;

/**
 * @brief SD Log1 Configuration message structure
 * @details Log selection and period for LOG1
 */
typedef struct  {
    U8 logSelection[10];                  /**< Log Selection - up to 80 flags indicating which telemetry frames should be logged  */
    U16 period;                           /**< Log period. Set to 0 to disable logging  */
    CUBEACP_SdLogSelect_t destination;    /**< Which SD card to use to store log file  */
} CUBEACP_LogSdConfig1_t;

/**
 * @brief SD Log2 Configuration message structure
 * @details Log selection and period for LOG2
 */
typedef struct  {
    U8 logSelection[10];                  /**< Log Selection - up to 80 flags indicating which telemetry frames should be logged  */
    U16 period;                           /**< Log period. Set to 0 to disable logging  */
    CUBEACP_SdLogSelect_t destination;    /**< Which SD card to use to store log file  */
} CUBEACP_LogSdConfig2_t;

/**
 * @brief UART Log Configuration message structure
 * @details Log selection and period for UART (unsolicited TLM)
 */
typedef struct  {
    U8 selection[10];    /**< Log Selection - up to 80 flags indicating which telemetry frames should be logged  */
    U16 period;          /**< Log period. Set to 0 to disable logging  */
} CUBEACP_LogUartConfig_t;

/**
 * @brief Secondary Magnetometer Raw Measurements message structure
 * @details Secondary Magnetometer raw measurements
 */
typedef struct  {
    S16 magRawX;    /**< sampled A/D value  */
    S16 magRawY;    /**< sampled A/D value  */
    S16 magRawZ;    /**< sampled A/D value  */
} CUBEACP_MagRaw2_t;

/**
 * @brief SGP4 Orbit Parameters message structure
 * @details SGP4 Orbit Parameters
 */
typedef struct  {
    F64 inclination;     /**< Inclination  (measurment unit is [deg]. valid range is between 0 deg and 180 deg) */
    F64 eccentricity;    /**< Eccentricity  (valid range is between 0  and 1 ) */
    F64 raan;            /**< Right-ascension of the Ascending Node  (measurment unit is [deg]. valid range is between 0 deg and 360 deg) */
    F64 argPerigee;      /**< Argument of Perigee  (measurment unit is [deg]. valid range is between 0 deg and 360 deg) */
    F64 bstar;           /**< B-Star drag term  (valid range is between 0  and 1 ) */
    F64 meanMotion;      /**< Mean Motion  (measurment unit is [orbits/day]. valid range is between 0 orbits/day and 20 orbits/day) */
    F64 meanAnomaly;     /**< Mean Anomaly  (measurment unit is [deg]. valid range is between 0 deg and 360 deg) */
    F64 epoch;           /**< Epoch (year.day)  (measurment unit is [year.day]. valid range is between 0 year.day and 100000 year.day) */
} CUBEACP_OrbitParameters_t;

/**
 * @brief Raw GPS Measurements message structure
 * @details Raw GPS measurements
 */
typedef struct  {
    CUBEACP_GpsSolutionStatus_t gpsSolutionStatus;    /**< GPS Solution Status  */
    U8 gpsNumSatsTracked;                             /**< Number of tracked GPS satellites  */
    U8 gpsNumSatsSolution;                            /**< Number of GPS satellites used in solution  */
    U8 gpsXYZLogCtr;                                  /**< Counter for XYZ Lof from GPS  */
    U8 gpsRangeLogCtr;                                /**< Counter for RANGE log from GPS  */
    U8 gpsResponse;                                   /**< Response Message for GPS log setup - p656 of OEMV615 reference manual  */
    U16 gpsWeek;                                      /**< GPS Reference Week  */
    U32 gpsTimeMs;                                    /**< GPS Time Milliseconds  (measurment unit is [ms]) */
    S32 posEcefX;                                     /**< ECEF Position X  (measurment unit is [m]) */
    S16 velEcefX;                                     /**< ECEF Velocity X  (measurment unit is [m/s]) */
    S32 posEcefY;                                     /**< ECEF Position Y  (measurment unit is [m]) */
    S16 velEcefY;                                     /**< ECEF Velocity Y  (measurment unit is [m/s]) */
    S32 posEcefZ;                                     /**< ECEF Position Z  (measurment unit is [m]) */
    S16 velEcefZ;                                     /**< ECEF Velocity Z  (measurment unit is [m/s]) */
    F64 stdDevPosX;                                   /**< X-pos Standard Deviation  (measurment unit is [m]) */
    F64 stdDevPosY;                                   /**< Y-pos Standard Deviation  (measurment unit is [m]) */
    F64 stdDevPosZ;                                   /**< Z-pos Standard Deviation  (measurment unit is [m]) */
    U8 stdDevVelX;                                    /**< X-vel Standard Deviation  (measurment unit is [m/s]) */
    U8 stdDevVelY;                                    /**< Y-vel Standard Deviation  (measurment unit is [m/s]) */
    U8 stdDevVelZ;                                    /**< Z-vel Standard Deviation  (measurment unit is [m/s]) */
} CUBEACP_RawGPS_t;

/**
 * @brief Raw Sensor Measurements message structure
 * @details Raw sensor measurements
 */
typedef struct  {
    S16 cam2RawX;                         /**< Cam2 azimuth angle  */
    S16 cam2RawY;                         /**< Cam2 elevation angle  */
    CUBEACP_CaptureResult_t cam2Busy;     /**< Cam2 capture status  */
    CUBEACP_DetectResult_t cam2Result;    /**< Cam2 detection result  */
    S16 cam1RawX;                         /**< Cam1 azimuth angle  */
    S16 cam1RawY;                         /**< Cam1 elevation angle  */
    CUBEACP_CaptureResult_t cam1Busy;     /**< Cam1 capture status  */
    CUBEACP_DetectResult_t cam1Result;    /**< Cam1 detection result  */
    U8 cssRaw1;                           /**< sampled A/D value - corresponds to COS(sun_angle)  */
    U8 cssRaw2;                           /**< sampled A/D value - corresponds to COS(sun_angle)  */
    U8 cssRaw3;                           /**< sampled A/D value - corresponds to COS(sun_angle)  */
    U8 cssRaw4;                           /**< sampled A/D value - corresponds to COS(sun_angle)  */
    U8 cssRaw5;                           /**< sampled A/D value - corresponds to COS(sun_angle)  */
    U8 cssRaw6;                           /**< sampled A/D value - corresponds to COS(sun_angle)  */
    U8 cssRaw7;                           /**< sampled A/D value - corresponds to COS(sun_angle)  */
    U8 cssRaw8;                           /**< sampled A/D value - corresponds to COS(sun_angle)  */
    U8 cssRaw9;                           /**< sampled A/D value - corresponds to COS(sun_angle)  */
    U8 cssRaw10;                          /**< sampled A/D value - corresponds to COS(sun_angle)  */
    S16 magRawX;                          /**< sampled A/D value  */
    S16 magRawY;                          /**< sampled A/D value  */
    S16 magRawZ;                          /**< sampled A/D value  */
    S16 rawRateX;                         /**< sampled A/D value  */
    S16 rawRateY;                         /**< sampled A/D value  */
    S16 rawRateZ;                         /**< sampled A/D value  */
} CUBEACP_RawSensor_t;

/**
 * @brief Raw Star Tracker message structure
 * @details Raw Star Tracker Measurement
 */
typedef struct  {
    U8 numStarsDetected;               /**< Number of stars detected  (measurment unit is [stars]) */
    U8 starImageNoise;                 /**< Star image noise  (measurment unit is [noise]) */
    U8 invalidStars;                   /**< Number of invalid stars detected  (measurment unit is [Invalid stars]) */
    U8 numberOfStarsID;                /**< Number of stars identified  (measurment unit is [stars]) */
    CUBEACP_StarIDModeVal_t iDmode;    /**< Identification mode  (measurment unit is [ID mode]) */
    U8 imageDarkValue;                 /**< The average value of center line in image  (measurment unit is [8-bit pixel value]) */
    Boolean imageCaptureSuccess;       /**< Image Capture Success  (measurment unit is [flag]) */
    Boolean detectionSuccess;          /**< Detection Success  (measurment unit is [flag]) */
    Boolean identificationSuccess;     /**< Identification Success  (measurment unit is [flag]) */
    Boolean attitudeSuccess;           /**< Attitude Success  (measurment unit is [flag]) */
    Boolean processingTimeError;       /**< Processing time Error  (measurment unit is [flag]) */
    Boolean trackingModuleEnabled;     /**< Tracking Module Enabled  (measurment unit is [flag]) */
    Boolean predictionEnabled;         /**< Prediction Enabled  (measurment unit is [flag]) */
    Boolean commsError;                /**< Comms error  (measurment unit is [flag]) */
    U16 deltaT;                        /**< Sample Period  */
    U8 s1Conf;                         /**< Star 1 confidence  (measurment unit is [percentage]) */
    U8 s2Conf;                         /**< Star 2 confidence  (measurment unit is [percentage]) */
    U8 s3Conf;                         /**< Star 3 confidence  (measurment unit is [percentage]) */
    U16 magStar1;                      /**< Instrument magnitude of star 1  */
    U16 magStar2;                      /**< Instrument magnitude of star 2  */
    U16 magStar3;                      /**< Instrument magnitude of star 3  */
    U16 catStar1;                      /**< Catalogue number of star 1  */
    S16 centXStar1;                    /**< X centroid of star 1  */
    S16 centYStar1;                    /**< Y centroid of star 1  */
    U16 catStar2;                      /**< Catalogue number of star 2  */
    S16 centXStar2;                    /**< X centroid of star 2  */
    S16 centYStar2;                    /**< Y centroid of star 2  */
    U16 catStar3;                      /**< Catalogue number of star 3  */
    S16 centXStar3;                    /**< X centroid of star 3  */
    S16 centYStar3;                    /**< Y centroid of star 3  */
    U16 capture;                       /**< Capture  (measurment unit is [ms]) */
    U16 detection;                     /**< Detection  (measurment unit is [ms]) */
    U16 identification;                /**< Identification  (measurment unit is [ms]) */
    F64 starRateX;                     /**< Estimated Rate around CubeStar X-axis  */
    F64 starRateY;                     /**< Estimated Rate around CubeStar Y-axis  */
    F64 starRateZ;                     /**< Estimated Rate around CubeStar Z-axis  */
    F64 starQbar0;                     /**< CubeStar estimated attitude Q1  */
    F64 starQbar1;                     /**< CubeStar estimated attitude Q2  */
    F64 starQbar2;                     /**< CubeStar estimated attitude Q3  */
} CUBEACP_RawStarTracker_t;

/**
 * @brief Save Image message structure
 * @details Save and capture image from one of CubeSense cameras or CubeStar camera to SD card
 */
typedef struct  {
    CUBEACP_CamSelect_t cameraSelect;    /**< Camera Selection  (measurment unit is [s]) */
    CUBEACP_ImSize_t imageSize;          /**< Image size selection  (measurment unit is [s]) */
} CUBEACP_SaveImage_t;

/**
 * @brief Set Magnetorquer Output message structure
 * @details Set magnetorquer output (only valid if Control Mode is None)
 */
typedef struct  {
    F64 torquerX;    /**< Commanded X-torquer duty cycle  (valid range is between -800  and 800 ) */
    F64 torquerY;    /**< Commanded Y-torquer duty cycle  (valid range is between -800  and 800 ) */
    F64 torquerZ;    /**< Commanded Z-torquer duty cycle  (valid range is between -800  and 800 ) */
} CUBEACP_TorquerCmd_t;

/**
 * @brief Trigger ADCS Loop with Simulated Sensor Data message structure
 * @details Trigger ADCS to perform one iteration of the control loop (only valid when ADCS Run Mode is Triggered)
 */
typedef struct  {
    U32 unixTime;                                     /**< Unix time for iteration  (measurment unit is [s]) */
    U16 cssRaw1;                                      /**< CSS1 raw measurement  */
    U16 cssRaw2;                                      /**< CSS2 raw measurement  */
    U16 cssRaw3;                                      /**< CSS3 raw measurement  */
    U16 cssRaw4;                                      /**< CSS4 raw measurement  */
    U16 cssRaw5;                                      /**< CSS5 raw measurement  */
    U16 cssRaw6;                                      /**< CSS6 raw measurement  */
    U16 cssRaw7;                                      /**< CSS7 raw measurement  */
    U16 cssRaw8;                                      /**< CSS8 raw measurement  */
    U16 cssRaw9;                                      /**< CSS9 raw measurement  */
    U16 cssRaw10;                                     /**< CSS10 raw measurement  */
    S16 cam1RawX;                                     /**< Cam1 sensor raw X angle  */
    S16 cam1RawY;                                     /**< Cam1 sensor raw Y angle  */
    U8 cam1Busy;                                      /**< Cam1 sensor capture status  */
    U8 cam1Result;                                    /**< Cam1 sensor detection result  */
    S16 cam2RawX;                                     /**< Cam2 sensor raw X angle  */
    S16 cam2RawY;                                     /**< Cam2 sensor raw Y angle  */
    U8 cam2Busy;                                      /**< Cam2 sensor capture status  */
    U8 cam2Result;                                    /**< Cam2 sensor detection result  */
    S16 magRawX;                                      /**< Raw magnetometer X measurement  */
    S16 magRawY;                                      /**< Raw magnetometer Y measurement  */
    S16 magRawZ;                                      /**< Raw magnetometer Z measurement  */
    S32 rateRawX;                                     /**< Raw X rate sensor measurement  */
    S32 rateRawY;                                     /**< Raw Y rate sensor measurement  */
    S32 rateRawZ;                                     /**< Raw Z rate sensor measurement  */
    S16 wheelRawX;                                    /**< Raw X wheel speed measurement  (measurment unit is [rpm]) */
    S16 wheelRawY;                                    /**< Raw Y wheel speed measurement  (measurment unit is [rpm]) */
    S16 wheelRawZ;                                    /**< Raw Z wheel speed measurement  (measurment unit is [rpm]) */
    S16 star1CameraX;                                 /**< Star1 camera X-vector  */
    S16 star1CameraY;                                 /**< Star1 camera Y-vector  */
    S16 star1CameraZ;                                 /**< Star1 camera Z-vector  */
    S16 star1InertialX;                               /**< Star1 inertial X-vector  */
    S16 star1InertialY;                               /**< Star1 inertial Y-vector  */
    S16 star1InertialZ;                               /**< Star1 inertial Z-vector  */
    S16 star2CameraX;                                 /**< Star2 camera X-vector  */
    S16 star2CameraY;                                 /**< Star2 camera Y-vector  */
    S16 star2CameraZ;                                 /**< Star2 camera Z-vector  */
    S16 star2InertialX;                               /**< Star2 inertial X-vector  */
    S16 star2InertialY;                               /**< Star2 inertial Y-vector  */
    S16 star2InertialZ;                               /**< Star2 inertial Z-vector  */
    S16 star3CameraX;                                 /**< Star3 camera X-vector  */
    S16 star3CameraY;                                 /**< Star3 camera Y-vector  */
    S16 star3CameraZ;                                 /**< Star3 camera Z-vector  */
    S16 star3InertialX;                               /**< Star3 inertial X-vector  */
    S16 star3InertialY;                               /**< Star3 inertial Y-vector  */
    S16 star3InertialZ;                               /**< Star3 inertial Z-vector  */
    CUBEACP_GpsSolutionStatus_t gpsSolutionStatus;    /**< GPS Solution Status  */
    U16 gpsWeek;                                      /**< GPS Reference Week  */
    U32 gpsTimeMs;                                    /**< GPS Time Milliseconds  (measurment unit is [ms]) */
    S32 posEcefX;                                     /**< ECEF Position X  (measurment unit is [m]) */
    S16 velEcefX;                                     /**< ECEF Velocity X  (measurment unit is [m/s]) */
    S32 posEcefY;                                     /**< ECEF Position Y  (measurment unit is [m]) */
    S16 velEcefY;                                     /**< ECEF Velocity Y  (measurment unit is [m/s]) */
    S32 posEcefZ;                                     /**< ECEF Position Z  (measurment unit is [m]) */
    S16 velEcefZ;                                     /**< ECEF Velocity Z  (measurment unit is [m/s]) */
    F64 stdDevPosX;                                   /**< X-pos Standard Deviation  (measurment unit is [m]) */
    F64 stdDevPosY;                                   /**< Y-pos Standard Deviation  (measurment unit is [m]) */
    F64 stdDevPosZ;                                   /**< Z-pos Standard Deviation  (measurment unit is [m]) */
    U8 stdDevVelX;                                    /**< X-vel Standard Deviation  (measurment unit is [m/s]) */
    U8 stdDevVelY;                                    /**< Y-vel Standard Deviation  (measurment unit is [m/s]) */
    U8 stdDevVelZ;                                    /**< Z-vel Standard Deviation  (measurment unit is [m/s]) */
} CUBEACP_TriggerAdcsSensor_t;

/**
 * @brief Set Wheel Speed message structure
 * @details Set wheel speed (only valid if Control Mode is None)
 */
typedef struct  {
    S16 wheelX;    /**< Commanded X-wheel speed  (measurment unit is [rpm]. valid range is between -8000 rpm and 8000 rpm) */
    S16 wheelY;    /**< Commanded Y-wheel speed  (measurment unit is [rpm]. valid range is between -8000 rpm and 8000 rpm) */
    S16 wheelZ;    /**< Commanded Z-wheel speed  (measurment unit is [rpm]. valid range is between -8000 rpm and 8000 rpm) */
} CUBEACP_WheelSpeedCmd_t;


/*******************************************************************************
 *****************************   PROTOTYPES   **********************************
 ******************************************************************************/

/***************************************************************************//**
Return the expected length of a telemetry frame
 *
 * @param[in] tlm
 *   Enumeration of specified telemetry request
 * @return
 *   Returns the length of the telemetry frame in bytes
 ******************************************************************************/
uint16_t CUBEACP_GetTlmLen(CUBEACP_Telemetry_t tlm);

/***************************************************************************//**
 * Decode a ACP Execution State telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_AcpLoopState_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractAcpLoopStateTlm(uint8_t* rxBuffer, CUBEACP_AcpLoopState_t* returnVal);

/***************************************************************************//**
 * Decode a Actuator Commands telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_ActuatorCmd_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractActuatorCmdTlm(uint8_t* rxBuffer, CUBEACP_ActuatorCmd_t* returnVal);

/***************************************************************************//**
 * Decode a ADCS Configuration telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_AdcsConfig_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 *      TlmRangeError if the Star Tracker Centroid X telemetry value was outside of the range -5000  to 5000 
 *      TlmRangeError if the Star Tracker Centroid Y telemetry value was outside of the range -5000  to 5000 
 *      TlmRangeError if the Star Tracker Focal Length telemetry value was outside of the range 5 mm to 7 mm
 *      TlmRangeError if the K1 radial distortion coefficient telemetry value was outside of the range -1 gain to 1 gain
 *      TlmRangeError if the K2 radial distortion coefficient telemetry value was outside of the range -1 gain to 1 gain
 *      TlmRangeError if the P1 tangential distortion coefficient telemetry value was outside of the range -1 gain to 1 gain
 *      TlmRangeError if the P2 tangential distortion coefficient telemetry value was outside of the range -1 gain to 1 gain
 *      TlmRangeError if the Detumbling Spin Gain telemetry value was outside of the range 0  to 10000 
 *      TlmRangeError if the Detumbling Damping Gain telemetry value was outside of the range 0  to 10000 
 *      TlmRangeError if the Reference spin rate telemetry value was outside of the range -32000 deg/s to 32000 deg/s
 *      TlmRangeError if the Fast BDot Detumbling Gain telemetry value was outside of the range 0  to 100 
 *      TlmRangeError if the Y-Momentum Control Gain telemetry value was outside of the range 0  to 10000 
 *      TlmRangeError if the Y-momentum Nutation Damping Gain telemetry value was outside of the range 0  to 10000 
 *      TlmRangeError if the Y-momentum Proportional Gain telemetry value was outside of the range 0  to 100 
 *      TlmRangeError if the Y-momentum Derivative Gain telemetry value was outside of the range 0  to 100 
 *      TlmRangeError if the Reference Wheel Momentum telemetry value was outside of the range -10 Nms to 0 Nms
 *      TlmRangeError if the RWheel Proportional Gain telemetry value was outside of the range 0  to 100 
 *      TlmRangeError if the RWheel Derivative Gain telemetry value was outside of the range 0  to 100 
 *      TlmRangeError if the Y-Wheel Bias Momentum telemetry value was outside of the range -10 Nms to 10 Nms
 *      TlmRangeError if the Tracking Proportional Gain telemetry value was outside of the range 0  to 100 
 *      TlmRangeError if the Tracking Derivative Gain telemetry value was outside of the range 0  to 100 
 *      TlmRangeError if the Tracking Integral Gain telemetry value was outside of the range 0  to 100 
 *      TlmRangeError if the Moment Of Inertia - Ixx telemetry value was outside of the range 0 kg.m^2 to 10 kg.m^2
 *      TlmRangeError if the Moment Of Inertia - Iyy telemetry value was outside of the range 0 kg.m^2 to 10 kg.m^2
 *      TlmRangeError if the Moment Of Inertia - Izz telemetry value was outside of the range 0 kg.m^2 to 10 kg.m^2
 *      TlmRangeError if the Product Of Inertia - Ixy telemetry value was outside of the range -10 kg.m^2 to 10 kg.m^2
 *      TlmRangeError if the Product Of Inertia - Ixz telemetry value was outside of the range -10 kg.m^2 to 10 kg.m^2
 *      TlmRangeError if the Product Of Inertia - Iyz telemetry value was outside of the range -10 kg.m^2 to 10 kg.m^2
 *      TlmRangeError if the Magnetometer Rate Filter System Noise telemetry value was outside of the range 0  to 100 
 *      TlmRangeError if the EKF System Noise telemetry value was outside of the range 0  to 100 
 *      TlmRangeError if the CSS Measurement Noise telemetry value was outside of the range 0  to 100 
 *      TlmRangeError if the Sun Sensor Measurement Noise telemetry value was outside of the range 0  to 100 
 *      TlmRangeError if the Nadir Sensor Measurement Noise telemetry value was outside of the range 0  to 100 
 *      TlmRangeError if the Magnetometer Measurement Noise telemetry value was outside of the range 0  to 100 
 *      TlmRangeError if the Star Tracker Measurement Noise telemetry value was outside of the range 0  to 100 
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractAdcsConfigTlm(uint8_t* rxBuffer, CUBEACP_AdcsConfig_t* returnVal);

/***************************************************************************//**
 * Decode a Adcs Execution Times telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_AdcsExecTimes_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractAdcsExecTimesTlm(uint8_t* rxBuffer, CUBEACP_AdcsExecTimes_t* returnVal);

/***************************************************************************//**
 * Decode a ADCS Measurements telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_AdcsMeasure_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractAdcsMeasureTlm(uint8_t* rxBuffer, CUBEACP_AdcsMeasure_t* returnVal);

/***************************************************************************//**
 * Decode a ADCS Misc Current Measurements telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_AdcsMiscCurrents_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractAdcsMiscCurrentsTlm(uint8_t* rxBuffer, CUBEACP_AdcsPowerMeasure_t* returnVal);

/***************************************************************************//**
 * Decode a ADCS Power Control telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_AdcsPower_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractAdcsPowerTlm(uint8_t* rxBuffer, CUBEACP_AdcsPower_t* returnVal);

/***************************************************************************//**
 * Decode a Power and Temperature Measurements telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_AdcsPowerMeasure_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractAdcsPowerMeasureTlm(uint8_t* rxBuffer, CUBEACP_AdcsPowerMeasure_t* returnVal);

/***************************************************************************//**
 * Decode a ADCS State telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_AdcsState_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractAdcsStateTlm(uint8_t* rxBuffer, CUBEACP_AdcsState_t* returnVal);

/***************************************************************************//**
 * Decode a ADCS System Configuration telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_AdcsSystemConfig_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 *      TlmRangeError if the Magnetorquer-X Max Dipole telemetry value was outside of the range 0 A.m^2 to 2 A.m^2
 *      TlmRangeError if the Magnetorquer-Y Max Dipole telemetry value was outside of the range 0 A.m^2 to 2 A.m^2
 *      TlmRangeError if the Magnetorquer-Z Max Dipole telemetry value was outside of the range 0 A.m^2 to 2 A.m^2
 *      TlmRangeError if the Magnetorquer On-time Resolution telemetry value was outside of the range 0 s to 1 s
 *      TlmRangeError if the Magnetorquer Maximum On-time telemetry value was outside of the range 0 s to 1 s
 *      TlmRangeError if the RW-X Maximum Torque telemetry value was outside of the range 0 N.m to 0.1 N.m
 *      TlmRangeError if the RW-Y Maximum Torque telemetry value was outside of the range 0 N.m to 0.1 N.m
 *      TlmRangeError if the RW-Z Maximum Torque telemetry value was outside of the range 0 N.m to 0.1 N.m
 *      TlmRangeError if the RW-X Maximum Momentum telemetry value was outside of the range 0 Nms to 0.1 Nms
 *      TlmRangeError if the RW-Y Maximum Momentum telemetry value was outside of the range 0 Nms to 0.1 Nms
 *      TlmRangeError if the RW-Z Maximum Momentum telemetry value was outside of the range 0 Nms to 0.1 Nms
 *      TlmRangeError if the RW-X Inertia telemetry value was outside of the range 0 kg.m^2 to 0.001 kg.m^2
 *      TlmRangeError if the RW-Y Inertia telemetry value was outside of the range 0 kg.m^2 to 0.001 kg.m^2
 *      TlmRangeError if the RW-Z Inertia telemetry value was outside of the range 0 kg.m^2 to 0.001 kg.m^2
 *      TlmRangeError if the RW Torque Increment telemetry value was outside of the range 0 N.m to 0.1 N.m
 *      TlmRangeError if the Primary MTM X-Bias d1 telemetry value was outside of the range -10  to 10 
 *      TlmRangeError if the Primary MTM Y-Bias d1 telemetry value was outside of the range -10  to 10 
 *      TlmRangeError if the Primary MTM Z-Bias d1 telemetry value was outside of the range -10  to 10 
 *      TlmRangeError if the Primary MTM X-Bias d2 telemetry value was outside of the range -10000  to 10000 
 *      TlmRangeError if the Primary MTM Y-Bias d2 telemetry value was outside of the range -10000  to 10000 
 *      TlmRangeError if the Primary MTM Z-Bias d2 telemetry value was outside of the range -10000  to 10000 
 *      TlmRangeError if the Primary MTM X-Sens s1 telemetry value was outside of the range -1  to 1 
 *      TlmRangeError if the Primary MTM Y-Sens s1 telemetry value was outside of the range -1  to 1 
 *      TlmRangeError if the Primary MTM Z-Sens s1 telemetry value was outside of the range -1  to 1 
 *      TlmRangeError if the Primary MTM X-Sens s2 telemetry value was outside of the range -10  to 10 
 *      TlmRangeError if the Primary MTM Y-Sens s2 telemetry value was outside of the range -10  to 10 
 *      TlmRangeError if the Primary MTM Z-Sens s2 telemetry value was outside of the range -10  to 10 
 *      TlmRangeError if the Redundant MTM X-Bias d1 telemetry value was outside of the range -10  to 10 
 *      TlmRangeError if the Redundant MTM Y-Bias d1 telemetry value was outside of the range -10  to 10 
 *      TlmRangeError if the Redundant MTM Z-Bias d1 telemetry value was outside of the range -10  to 10 
 *      TlmRangeError if the Redundant MTM X-Bias d2 telemetry value was outside of the range -10000  to 10000 
 *      TlmRangeError if the Redundant MTM Y-Bias d2 telemetry value was outside of the range -10000  to 10000 
 *      TlmRangeError if the Redundant MTM Z-Bias d2 telemetry value was outside of the range -10000  to 10000 
 *      TlmRangeError if the Redundant MTM X-Sens s1 telemetry value was outside of the range -1  to 1 
 *      TlmRangeError if the Redundant MTM Y-Sens s1 telemetry value was outside of the range -1  to 1 
 *      TlmRangeError if the Redundant MTM Z-Sens s1 telemetry value was outside of the range -1  to 1 
 *      TlmRangeError if the Redundant MTM X-Sens s2 telemetry value was outside of the range -10  to 10 
 *      TlmRangeError if the Redundant MTM Y-Sens s2 telemetry value was outside of the range -10  to 10 
 *      TlmRangeError if the Redundant MTM Z-Sens s2 telemetry value was outside of the range -10  to 10 
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractAdcsSystemConfigTlm(uint8_t* rxBuffer, CUBEACP_AdcsSystemConfig_t* returnVal);

/***************************************************************************//**
 * Decode a ADCS Temperatures telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_AdcsTemperatures1_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractAdcsTemperatures1Tlm(uint8_t* rxBuffer, CUBEACP_AdcsPowerMeasure_t* returnVal);

/***************************************************************************//**
 * Decode a Rate sensor temperatures telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_AdcsTemperatures2_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractAdcsTemperatures2Tlm(uint8_t* rxBuffer, CUBEACP_AdcsPowerMeasure_t* returnVal);

/***************************************************************************//**
 * Decode a ASGP4 TLEs telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_Asgp4KepTle_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractAsgp4KepTleTlm(uint8_t* rxBuffer, CUBEACP_Asgp4KepTle_t* returnVal);

/***************************************************************************//**
 * Decode a Augmented-SGP4 Parameters telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_ASgp4Params_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractASgp4ParamsTlm(uint8_t* rxBuffer, CUBEACP_AdcsConfig_t* returnVal);

/***************************************************************************//**
 * Decode a Commanded Attitude Angles telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_CmdAttitude_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 *      TlmRangeError if the Commanded Roll Angle telemetry value was outside of the range -9000 deg to 9000 deg
 *      TlmRangeError if the Commanded Pitch Angle telemetry value was outside of the range -18000 deg to 18000 deg
 *      TlmRangeError if the Commanded Yaw Angle telemetry value was outside of the range -18000 deg to 18000 deg
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractCmdAttitudeTlm(uint8_t* rxBuffer, CUBEACP_CmdAttitude_t* returnVal);

/***************************************************************************//**
 * Decode a Tracking Controller Target Reference telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_CmdTrackingTarget_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 *      TlmRangeError if the Geocentric longitude of target telemetry value was outside of the range 0 deg to 360 deg
 *      TlmRangeError if the Geocentric latitude of target telemetry value was outside of the range -90 deg to 90 deg
 *      TlmRangeError if the Geocentric altitude of target telemetry value was outside of the range -20000 meter to 40000000 meter
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractCmdTrackingTargetTlm(uint8_t* rxBuffer, CUBEACP_CmdTrackingTarget_t* returnVal);

/***************************************************************************//**
 * Decode a Coarse Sun Vector telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_CoarseSunVec_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractCoarseSunVecTlm(uint8_t* rxBuffer, CUBEACP_AdcsMeasure_t* returnVal);

/***************************************************************************//**
 * Decode a JPG Conversion Progress telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_ConversionProgress_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractConversionProgressTlm(uint8_t* rxBuffer, CUBEACP_ConversionProgress_t* returnVal);

/***************************************************************************//**
 * Decode a CSS Configuration telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_CssConfig_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractCssConfigTlm(uint8_t* rxBuffer, CUBEACP_AdcsConfig_t* returnVal);

/***************************************************************************//**
 * Decode a CubeACP State telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_CubeACPState_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractCubeACPStateTlm(uint8_t* rxBuffer, CUBEACP_CubeACPState_t* returnVal);

/***************************************************************************//**
 * Decode a CubeControl Current Measurements telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_CubeControlCurrents_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractCubeControlCurrentsTlm(uint8_t* rxBuffer, CUBEACP_AdcsPowerMeasure_t* returnVal);

/***************************************************************************//**
 * Decode a CubeSense1 Current Measurements telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_CubeSense1Currents_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractCubeSense1CurrentsTlm(uint8_t* rxBuffer, CUBEACP_AdcsPowerMeasure_t* returnVal);

/***************************************************************************//**
 * Decode a CubeSense2 Current Measurements telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_CubeSense2Currents_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractCubeSense2CurrentsTlm(uint8_t* rxBuffer, CUBEACP_AdcsPowerMeasure_t* returnVal);

/***************************************************************************//**
 * Decode a CubeSense Configuration telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_CubeSenseConfig_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractCubeSenseConfigTlm(uint8_t* rxBuffer, CUBEACP_AdcsConfig_t* returnVal);

/***************************************************************************//**
 * Decode a Current ADCS State telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_CurrentAdcsState_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractCurrentAdcsStateTlm(uint8_t* rxBuffer, CUBEACP_AdcsState_t* returnVal);

/***************************************************************************//**
 * Decode a Current ADCS State 2 telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_CurrentAdcsState2_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractCurrentAdcsState2Tlm(uint8_t* rxBuffer, CUBEACP_AdcsState_t* returnVal);

/***************************************************************************//**
 * Decode a Set Detumbling Control Parameters telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_DetumbleParams_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractDetumbleParamsTlm(uint8_t* rxBuffer, CUBEACP_AdcsConfig_t* returnVal);

/***************************************************************************//**
 * Decode a Estimated Attitude Angles telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_EstimAttitude_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractEstimAttitudeTlm(uint8_t* rxBuffer, CUBEACP_AdcsState_t* returnVal);

/***************************************************************************//**
 * Decode a Estimation Data telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_EstimData_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractEstimDataTlm(uint8_t* rxBuffer, CUBEACP_EstimData_t* returnVal);

/***************************************************************************//**
 * Decode a Estimated Gyro Bias telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_EstimGyroBias_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractEstimGyroBiasTlm(uint8_t* rxBuffer, CUBEACP_EstimData_t* returnVal);

/***************************************************************************//**
 * Decode a Estimation Parameters telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_EstimParams_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractEstimParamsTlm(uint8_t* rxBuffer, CUBEACP_AdcsConfig_t* returnVal);

/***************************************************************************//**
 * Decode a Estimated Quaternion telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_EstimQuaternion_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractEstimQuaternionTlm(uint8_t* rxBuffer, CUBEACP_AdcsState_t* returnVal);

/***************************************************************************//**
 * Decode a Estimated Angular Rates telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_EstimRates_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractEstimRatesTlm(uint8_t* rxBuffer, CUBEACP_AdcsState_t* returnVal);

/***************************************************************************//**
 * Decode a Fine Estimated Angular Rates telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_FineEstimRates_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractFineEstimRatesTlm(uint8_t* rxBuffer, CUBEACP_FineEstimRates_t* returnVal);

/***************************************************************************//**
 * Decode a Fine Sun Vector telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_FineSunVec_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractFineSunVecTlm(uint8_t* rxBuffer, CUBEACP_AdcsMeasure_t* returnVal);

/***************************************************************************//**
 * Decode a Set Rate Gyro Configuration telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_GyroConfig_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractGyroConfigTlm(uint8_t* rxBuffer, CUBEACP_AdcsConfig_t* returnVal);

/***************************************************************************//**
 * Decode a Status of Image Capture and Save Operation telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_ImageSaveStatus_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractImageSaveStatusTlm(uint8_t* rxBuffer, CUBEACP_ImageSaveStatus_t* returnVal);

/***************************************************************************//**
 * Decode a Inertial Pointing Reference Vector telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_InertialPointReference_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractInertialPointReferenceTlm(uint8_t* rxBuffer, CUBEACP_InertialPointReference_t* returnVal);

/***************************************************************************//**
 * Decode a Estimation Innovation Vector telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_InnovationVec_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractInnovationVecTlm(uint8_t* rxBuffer, CUBEACP_EstimData_t* returnVal);

/***************************************************************************//**
 * Decode a SD Log1 Configuration telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_LogSdConfig1_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractLogSdConfig1Tlm(uint8_t* rxBuffer, CUBEACP_LogSdConfig1_t* returnVal);

/***************************************************************************//**
 * Decode a SD Log2 Configuration telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_LogSdConfig2_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractLogSdConfig2Tlm(uint8_t* rxBuffer, CUBEACP_LogSdConfig2_t* returnVal);

/***************************************************************************//**
 * Decode a UART Log Configuration telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_LogUartConfig_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractLogUartConfigTlm(uint8_t* rxBuffer, CUBEACP_LogUartConfig_t* returnVal);

/***************************************************************************//**
 * Decode a Magnetometer Configuration telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_MagConfig_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractMagConfigTlm(uint8_t* rxBuffer, CUBEACP_AdcsConfig_t* returnVal);

/***************************************************************************//**
 * Decode a Magnetic Field Vector telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_MagField_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractMagFieldTlm(uint8_t* rxBuffer, CUBEACP_AdcsMeasure_t* returnVal);

/***************************************************************************//**
 * Decode a Secondary Magnetometer Raw Measurements telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_MagRaw2_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractMagRaw2Tlm(uint8_t* rxBuffer, CUBEACP_MagRaw2_t* returnVal);

/***************************************************************************//**
 * Decode a Set Magnetorquer Configuration telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_MagtorqConfig_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractMagtorqConfigTlm(uint8_t* rxBuffer, CUBEACP_AdcsConfig_t* returnVal);

/***************************************************************************//**
 * Decode a Magnetorquer Command telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_MagTorquerCmd_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractMagTorquerCmdTlm(uint8_t* rxBuffer, CUBEACP_ActuatorCmd_t* returnVal);

/***************************************************************************//**
 * Decode a IGRF Modelled Magnetic Field Vector telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_ModelMagVec_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractModelMagVecTlm(uint8_t* rxBuffer, CUBEACP_EstimData_t* returnVal);

/***************************************************************************//**
 * Decode a Modelled Sun Vector telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_ModelSunVec_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractModelSunVecTlm(uint8_t* rxBuffer, CUBEACP_EstimData_t* returnVal);

/***************************************************************************//**
 * Decode a Moment of Inertia Matrix telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_MoI_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractMoITlm(uint8_t* rxBuffer, CUBEACP_AdcsConfig_t* returnVal);

/***************************************************************************//**
 * Decode a Nadir Vector telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_NadirVec_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractNadirVecTlm(uint8_t* rxBuffer, CUBEACP_AdcsMeasure_t* returnVal);

/***************************************************************************//**
 * Decode a SGP4 Orbit Parameters telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_OrbitParameters_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 *      TlmRangeError if the Inclination telemetry value was outside of the range 0 deg to 180 deg
 *      TlmRangeError if the Eccentricity telemetry value was outside of the range 0  to 1 
 *      TlmRangeError if the Right-ascension of the Ascending Node telemetry value was outside of the range 0 deg to 360 deg
 *      TlmRangeError if the Argument of Perigee telemetry value was outside of the range 0 deg to 360 deg
 *      TlmRangeError if the B-Star drag term telemetry value was outside of the range 0  to 1 
 *      TlmRangeError if the Mean Motion telemetry value was outside of the range 0 orbits/day to 20 orbits/day
 *      TlmRangeError if the Mean Anomaly telemetry value was outside of the range 0 deg to 360 deg
 *      TlmRangeError if the Epoch telemetry value was outside of the range 0 year.day to 100000 year.day
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractOrbitParametersTlm(uint8_t* rxBuffer, CUBEACP_OrbitParameters_t* returnVal);

/***************************************************************************//**
 * Decode a ECEF Position telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_PositionECEF_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractPositionECEFTlm(uint8_t* rxBuffer, CUBEACP_AdcsState_t* returnVal);

/***************************************************************************//**
 * Decode a Satellite Position (ECI) telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_PositionECI_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractPositionECITlm(uint8_t* rxBuffer, CUBEACP_AdcsState_t* returnVal);

/***************************************************************************//**
 * Decode a Satellite Position (LLH) telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_PositionLLH_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractPositionLLHTlm(uint8_t* rxBuffer, CUBEACP_AdcsState_t* returnVal);

/***************************************************************************//**
 * Decode a Quaternion Covariance telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_QuaternionCovar_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractQuaternionCovarTlm(uint8_t* rxBuffer, CUBEACP_EstimData_t* returnVal);

/***************************************************************************//**
 * Decode a Quaternion Error Vector telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_QuaternionErrVec_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractQuaternionErrVecTlm(uint8_t* rxBuffer, CUBEACP_EstimData_t* returnVal);

/***************************************************************************//**
 * Decode a Angular Rate Covariance telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_RateCovar_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractRateCovarTlm(uint8_t* rxBuffer, CUBEACP_EstimData_t* returnVal);

/***************************************************************************//**
 * Decode a Rate Sensor Rates telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_RateSensor_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractRateSensorTlm(uint8_t* rxBuffer, CUBEACP_AdcsMeasure_t* returnVal);

/***************************************************************************//**
 * Decode a Raw Cam1 Sensor telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_RawCam1Sens_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractRawCam1SensTlm(uint8_t* rxBuffer, CUBEACP_RawSensor_t* returnVal);

/***************************************************************************//**
 * Decode a Raw Cam2 Sensor telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_RawCam2Sens_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractRawCam2SensTlm(uint8_t* rxBuffer, CUBEACP_RawSensor_t* returnVal);

/***************************************************************************//**
 * Decode a Raw CSS 1 to 6 telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_RawCss1_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractRawCss1Tlm(uint8_t* rxBuffer, CUBEACP_RawSensor_t* returnVal);

/***************************************************************************//**
 * Decode a Raw CSS 7 to 10 telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_RawCss2_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractRawCss2Tlm(uint8_t* rxBuffer, CUBEACP_RawSensor_t* returnVal);

/***************************************************************************//**
 * Decode a Raw GPS Measurements telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_RawGPS_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractRawGPSTlm(uint8_t* rxBuffer, CUBEACP_RawGPS_t* returnVal);

/***************************************************************************//**
 * Decode a Raw GPS Status telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_RawGpsStatus_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractRawGpsStatusTlm(uint8_t* rxBuffer, CUBEACP_RawGPS_t* returnVal);

/***************************************************************************//**
 * Decode a Raw GPS Time telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_RawGpsTime_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractRawGpsTimeTlm(uint8_t* rxBuffer, CUBEACP_RawGPS_t* returnVal);

/***************************************************************************//**
 * Decode a Raw GPS X telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_RawGpsX_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractRawGpsXTlm(uint8_t* rxBuffer, CUBEACP_RawGPS_t* returnVal);

/***************************************************************************//**
 * Decode a Raw GPS Y telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_RawGpsY_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractRawGpsYTlm(uint8_t* rxBuffer, CUBEACP_RawGPS_t* returnVal);

/***************************************************************************//**
 * Decode a Raw GPS Z telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_RawGpsZ_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractRawGpsZTlm(uint8_t* rxBuffer, CUBEACP_RawGPS_t* returnVal);

/***************************************************************************//**
 * Decode a Raw Magnetometer telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_RawMagnetometer_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractRawMagnetometerTlm(uint8_t* rxBuffer, CUBEACP_RawSensor_t* returnVal);

/***************************************************************************//**
 * Decode a Raw Rate Sensor telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_RawRate_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractRawRateTlm(uint8_t* rxBuffer, CUBEACP_RawSensor_t* returnVal);

/***************************************************************************//**
 * Decode a Raw Sensor Measurements telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_RawSensor_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractRawSensorTlm(uint8_t* rxBuffer, CUBEACP_RawSensor_t* returnVal);

/***************************************************************************//**
 * Decode a Raw Star Tracker telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_RawStarTracker_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractRawStarTrackerTlm(uint8_t* rxBuffer, CUBEACP_RawStarTracker_t* returnVal);

/***************************************************************************//**
 * Decode a Redundant Magnetometer Configuration telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_RedMagConfig_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractRedMagConfigTlm(uint8_t* rxBuffer, CUBEACP_AdcsConfig_t* returnVal);

/***************************************************************************//**
 * Decode a Set Reaction Wheel Control Parameters telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_RWheelParams_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractRWheelParamsTlm(uint8_t* rxBuffer, CUBEACP_AdcsConfig_t* returnVal);

/***************************************************************************//**
 * Decode a Wheel Speed Commands telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_SpeedCmd_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractSpeedCmdTlm(uint8_t* rxBuffer, CUBEACP_ActuatorCmd_t* returnVal);

/***************************************************************************//**
 * Decode a Star 1 Body Vector telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_Star1Body_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractStar1BodyTlm(uint8_t* rxBuffer, CUBEACP_AdcsMeasure_t* returnVal);

/***************************************************************************//**
 * Decode a Star 1 Orbit Vector telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_Star1Orbit_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractStar1OrbitTlm(uint8_t* rxBuffer, CUBEACP_AdcsMeasure_t* returnVal);

/***************************************************************************//**
 * Decode a Star 1 Raw Data telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_Star1Raw_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractStar1RawTlm(uint8_t* rxBuffer, CUBEACP_RawStarTracker_t* returnVal);

/***************************************************************************//**
 * Decode a Star 2 Body Vector telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_Star2Body_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractStar2BodyTlm(uint8_t* rxBuffer, CUBEACP_AdcsMeasure_t* returnVal);

/***************************************************************************//**
 * Decode a Star 2 Orbit Vector telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_Star2Orbit_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractStar2OrbitTlm(uint8_t* rxBuffer, CUBEACP_AdcsMeasure_t* returnVal);

/***************************************************************************//**
 * Decode a Star 2 Raw Data telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_Star2Raw_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractStar2RawTlm(uint8_t* rxBuffer, CUBEACP_RawStarTracker_t* returnVal);

/***************************************************************************//**
 * Decode a Star 3 Body Vector telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_Star3Body_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractStar3BodyTlm(uint8_t* rxBuffer, CUBEACP_AdcsMeasure_t* returnVal);

/***************************************************************************//**
 * Decode a Star 3 Orbit Vector telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_Star3Orbit_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractStar3OrbitTlm(uint8_t* rxBuffer, CUBEACP_AdcsMeasure_t* returnVal);

/***************************************************************************//**
 * Decode a Star 3 Raw Data telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_Star3Raw_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractStar3RawTlm(uint8_t* rxBuffer, CUBEACP_RawStarTracker_t* returnVal);

/***************************************************************************//**
 * Decode a Set Star Tracker Configuration telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_StarConfig_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractStarConfigTlm(uint8_t* rxBuffer, CUBEACP_AdcsConfig_t* returnVal);

/***************************************************************************//**
 * Decode a CubeStar Estimated Quaternion telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_StarEstimQ_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractStarEstimQTlm(uint8_t* rxBuffer, CUBEACP_RawStarTracker_t* returnVal);

/***************************************************************************//**
 * Decode a CubeStar Estimated Rates telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_StarEstimRate_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractStarEstimRateTlm(uint8_t* rxBuffer, CUBEACP_RawStarTracker_t* returnVal);

/***************************************************************************//**
 * Decode a Star Magnitude telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_StarMagnitude_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractStarMagnitudeTlm(uint8_t* rxBuffer, CUBEACP_RawStarTracker_t* returnVal);

/***************************************************************************//**
 * Decode a Star Performance1 telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_StarPerformance1_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractStarPerformance1Tlm(uint8_t* rxBuffer, CUBEACP_RawStarTracker_t* returnVal);

/***************************************************************************//**
 * Decode a Star Performance2 telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_StarPerformance2_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractStarPerformance2Tlm(uint8_t* rxBuffer, CUBEACP_RawStarTracker_t* returnVal);

/***************************************************************************//**
 * Decode a Star Timing telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_StarTiming_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractStarTimingTlm(uint8_t* rxBuffer, CUBEACP_RawStarTracker_t* returnVal);

/***************************************************************************//**
 * Decode a Set Tracking Controller Gain Parameters telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_TrackingParams_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractTrackingParamsTlm(uint8_t* rxBuffer, CUBEACP_AdcsConfig_t* returnVal);

/***************************************************************************//**
 * Decode a User-coded Controller and Estimator Parameters telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_UserConEstParams_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractUserConEstParamsTlm(uint8_t* rxBuffer, CUBEACP_AdcsConfig_t* returnVal);

/***************************************************************************//**
 * Decode a Satellite Velocity (ECI) telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_VelocityECI_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractVelocityECITlm(uint8_t* rxBuffer, CUBEACP_AdcsState_t* returnVal);

/***************************************************************************//**
 * Decode a Set Wheel Configuration telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_WheelConfig_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractWheelConfigTlm(uint8_t* rxBuffer, CUBEACP_AdcsConfig_t* returnVal);

/***************************************************************************//**
 * Decode a Wheel Currents telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_WheelCurrents_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractWheelCurrentsTlm(uint8_t* rxBuffer, CUBEACP_AdcsPowerMeasure_t* returnVal);

/***************************************************************************//**
 * Decode a Wheel Speed telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_WheelSpeed_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractWheelSpeedTlm(uint8_t* rxBuffer, CUBEACP_AdcsMeasure_t* returnVal);

/***************************************************************************//**
 * Decode a Set Y-Wheel Control Parameters telemetry frame from the CubeACP
 *
 * @param[in] rxBuffer
 *   Buffer containing raw bytes
 * @param[in] returnVal
 *   Pointer to a CUBEACP_YWheelParams_t struct in which the telemetry will be returned.
 * @return
 *   Returns a value from the CUBEADCS_Result_t enumeration:
 *      CubeLibOk if the telemetry was decoded without error
 *      PointerIsNull if the input parameter, returnVal, was NULL
 ******************************************************************************/
CUBEADCS_Result_t CUBEACP_ExtractYWheelParamsTlm(uint8_t* rxBuffer, CUBEACP_AdcsConfig_t* returnVal);

/***************************************************************************//**
 * Send a ADCS Configuration command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @param[in] magtorq1
 *   Magnetorquer 1 Configuration
 * @param[in] magtorq2
 *   Magnetorquer 2 Configuration
 * @param[in] magtorq3
 *   Magnetorquer 3 Configuration
 * @param[in] rW1Conf
 *   RW1 Configuration
 * @param[in] rW2Conf
 *   RW2 Configuration
 * @param[in] rW3Conf
 *   RW3 Configuration
 * @param[in] rW4Conf
 *   RW4 or Momentum wheel Configuration
 * @param[in] gyro1Conf
 *   Gyro1 Configuration
 * @param[in] gyro2Conf
 *   Gyro2 Configuration
 * @param[in] gyro3Conf
 *   Gyro3 Configuration
 * @param[in] xRateOffset
 *   X-Rate Sensor Offset
 *   (in [deg/s] units)
 * @param[in] yRateOffset
 *   Y-Rate Sensor Offset
 *   (in [deg/s] units)
 * @param[in] zRateOffset
 *   Z-Rate Sensor Offset
 *   (in [deg/s] units)
 * @param[in] rateSensorMult
 *   Multiplier of rate sensor measurement
 * @param[in] css1Conf
 *   CSS1 Configuration
 * @param[in] css2Conf
 *   CSS2 Configuration
 * @param[in] css3Conf
 *   CSS3 Configuration
 * @param[in] css4Conf
 *   CSS4 Configuration
 * @param[in] css5Conf
 *   CSS5 Configuration
 * @param[in] css6Conf
 *   CSS6 Configuration
 * @param[in] css7Conf
 *   CSS7 Configuration
 * @param[in] css8Conf
 *   CSS8 Configuration
 * @param[in] css9Conf
 *   CSS9 Configuration
 * @param[in] css10Conf
 *   CSS10 Configuration
 * @param[in] css1Scale
 *   CSS1 Relative Scaling Factor
 * @param[in] css2Scale
 *   CSS2 Relative Scaling Factor
 * @param[in] css3Scale
 *   CSS3 Relative Scaling Factor
 * @param[in] css4Scale
 *   CSS4 Relative Scaling Factor
 * @param[in] css5Scale
 *   CSS5 Relative Scaling Factor
 * @param[in] css6Scale
 *   CSS6 Relative Scaling Factor
 * @param[in] css7Scale
 *   CSS7 Relative Scaling Factor
 * @param[in] css8Scale
 *   CSS8 Relative Scaling Factor
 * @param[in] css9Scale
 *   CSS9 Relative Scaling Factor
 * @param[in] css10Scale
 *   CSS10 Relative Scaling Factor
 * @param[in] cssMinimum
 *   CSS Threshold
 * @param[in] cam1Angle1
 *   Cam1 Sensor Mounting Transform Alpha Angle
 *   (in [deg] units)
 * @param[in] cam1Angle2
 *   Cam1 Sensor Mounting Transform Beta Angle
 *   (in [deg] units)
 * @param[in] cam1Angle3
 *   Cam1 Sensor Mounting Transform Gamma Angle
 *   (in [deg] units)
 * @param[in] cam1Threshold
 *   Cam1 detection threshold
 * @param[in] cam1AutoAdj
 *   0 = disabled and 1 = enabled
 * @param[in] reserved
 *   
 * @param[in] cam1Exposure
 *   exposure time register value
 * @param[in] cam1BoreX
 *   X Pixel location of Cam1 boresight
 *   (in [pixels] units)
 * @param[in] cam1BoreY
 *   Y Pixel location of Cam1 boresight
 *   (in [pixels] units)
 * @param[in] cam2Angle1
 *   Cam2 Sensor Mounting Transform Alpha Angle
 *   (in [deg] units)
 * @param[in] cam2Angle2
 *   Cam2 Sensor Mounting Transform Beta Angle
 *   (in [deg] units)
 * @param[in] cam2Angle3
 *   Cam2 Sensor Mounting Transform Gamma Angle
 *   (in [deg] units)
 * @param[in] cam2Threshold
 *   Cam2 detection threshold
 * @param[in] cam2AutoAdj
 *   0 = disabled and 1 = enabled
 * @param[in] reserved
 *   
 * @param[in] cam2Exposure
 *   exposure time register value
 * @param[in] cam2BoreX
 *   X Pixel location of Cam2 boresight
 *   (in [pixels] units)
 * @param[in] cam2BoreY
 *   Y Pixel location of Cam2 boresight
 *   (in [pixels] units)
 * @param[in] nadirMaxDeviationPercentage
 *   Percentage of measured angular radius as edge's maximum allowable deviation
 * @param[in] nadirMaxBadEdges
 *   Maximum amount of edges allowed outside maximum deviation (>50 to disable)
 * @param[in] nadirMaxRadius
 *   Maximum Radius
 *   (in [°] units)
 * @param[in] nadirMinRadius
 *   Minimum Radius
 *   (in [°] units)
 * @param[in] cam1MaskArea1Xmin
 *   Cam 1 Minimum X of Area 1
 * @param[in] cam1MaskArea1Xmax
 *   Cam 1 Maximum X of Area 1
 * @param[in] cam1MaskArea1Ymin
 *   Cam 1 Minimum Y of Area 1
 * @param[in] cam1MaskArea1Ymax
 *   Cam 1 Maximum Y of Area 1
 * @param[in] cam1MaskArea2Xmin
 *   Cam 1 Minimum X of Area 2
 * @param[in] cam1MaskArea2Xmax
 *   Cam 1 Maximum X of Area 2
 * @param[in] cam1MaskArea2Ymin
 *   Cam 1 Minimum Y of Area 2
 * @param[in] cam1MaskArea2Ymax
 *   Cam 1 Maximum Y of Area 2
 * @param[in] cam1MaskArea3Xmin
 *   Cam 1 Minimum X of Area 3
 * @param[in] cam1MaskArea3Xmax
 *   Cam 1 Maximum X of Area 3
 * @param[in] cam1MaskArea3Ymin
 *   Cam 1 Minimum Y of Area 3
 * @param[in] cam1MaskArea3Ymax
 *   Cam 1 Maximum Y of Area 3
 * @param[in] cam1MaskArea4Xmin
 *   Cam 1 Minimum X of Area 4
 * @param[in] cam1MaskArea4Xmax
 *   Cam 1 Maximum X of Area 4
 * @param[in] cam1MaskArea4Ymin
 *   Cam 1 Minimum Y of Area 4
 * @param[in] cam1MaskArea4Ymax
 *   Cam 1 Maximum Y of Area 4
 * @param[in] cam1MaskArea5Xmin
 *   Cam 1 Minimum X of Area 5
 * @param[in] cam1MaskArea5Xmax
 *   Cam 1 Maximum X of Area 5
 * @param[in] cam1MaskArea5Ymin
 *   Cam 1 Minimum Y of Area 5
 * @param[in] cam1MaskArea5Ymax
 *   Cam 1 Maximum Y of Area 5
 * @param[in] cam2MaskArea1Xmin
 *   Cam 2 Minimum X of Area 1
 * @param[in] cam2MaskArea1Xmax
 *   Cam 2 Maximum X of Area 1
 * @param[in] cam2MaskArea1Ymin
 *   Cam 2 Minimum Y of Area 1
 * @param[in] cam2MaskArea1Ymax
 *   Cam 2 Maximum Y of Area 1
 * @param[in] cam2MaskArea2Xmin
 *   Cam 2 Minimum X of Area 2
 * @param[in] cam2MaskArea2Xmax
 *   Cam 2 Maximum X of Area 2
 * @param[in] cam2MaskArea2Ymin
 *   Cam 2 Minimum Y of Area 2
 * @param[in] cam2MaskArea2Ymax
 *   Cam 2 Maximum Y of Area 2
 * @param[in] cam2MaskArea3Xmin
 *   Cam 2 Minimum X of Area 3
 * @param[in] cam2MaskArea3Xmax
 *   Cam 2 Maximum X of Area 3
 * @param[in] cam2MaskArea3Ymin
 *   Cam 2 Minimum Y of Area 3
 * @param[in] cam2MaskArea3Ymax
 *   Cam 2 Maximum Y of Area 3
 * @param[in] cam2MaskArea4Xmin
 *   Cam 2 Minimum X of Area 4
 * @param[in] cam2MaskArea4Xmax
 *   Cam 2 Maximum X of Area 4
 * @param[in] cam2MaskArea4Ymin
 *   Cam 2 Minimum Y of Area 4
 * @param[in] cam2MaskArea4Ymax
 *   Cam 2 Maximum Y of Area 4
 * @param[in] cam2MaskArea5Xmin
 *   Cam 2 Minimum X of Area 5
 * @param[in] cam2MaskArea5Xmax
 *   Cam 2 Maximum X of Area 5
 * @param[in] cam2MaskArea5Ymin
 *   Cam 2 Minimum Y of Area 5
 * @param[in] cam2MaskArea5Ymax
 *   Cam 2 Maximum Y of Area 5
 * @param[in] magmAngle1
 *   Magnetometer Mounting Transform Alpha Angle
 *   (in [deg] units)
 * @param[in] magmAngle2
 *   Magnetometer Mounting Transform Beta Angle
 *   (in [deg] units)
 * @param[in] magmAngle3
 *   Magnetometer Mounting Transform Gamma Angle
 *   (in [deg] units)
 * @param[in] magmOffset1
 *   Magnetometer Channel 1 Offset
 * @param[in] magmOffset2
 *   Magnetometer Channel 2 Offset
 * @param[in] magmOffset3
 *   Magnetometer Channel 3 Offset
 * @param[in] magmSens11
 *   Magnetometer Sensitivity Matrix S11
 * @param[in] magmSens22
 *   Magnetometer Sensitivity Matrix S22
 * @param[in] magmSens33
 *   Magnetometer Sensitivity Matrix S33
 * @param[in] magmSens12
 *   Magnetometer Sensitivity Matrix S12
 * @param[in] magmSens13
 *   Magnetometer Sensitivity Matrix S13
 * @param[in] magmSens21
 *   Magnetometer Sensitivity Matrix S21
 * @param[in] magmSens23
 *   Magnetometer Sensitivity Matrix S23
 * @param[in] magmSens31
 *   Magnetometer Sensitivity Matrix S31
 * @param[in] magmSens32
 *   Magnetometer Sensitivity Matrix S32
 * @param[in] mredAngle1
 *   Redundant Magnetometer Mounting Transform Alpha Angle
 *   (in [deg] units)
 * @param[in] mredAngle2
 *   Redundant Magnetometer Mounting Transform Beta Angle
 *   (in [deg] units)
 * @param[in] mredAngle3
 *   Redundant Magnetometer Mounting Transform Gamma Angle
 *   (in [deg] units)
 * @param[in] mredOffset1
 *   Redundant Magnetometer Channel 1 Offset
 * @param[in] mredOffset2
 *   Redundant Magnetometer Channel 2 Offset
 * @param[in] mredOffset3
 *   Redundant Magnetometer Channel 3 Offset
 * @param[in] mredSens11
 *   Redundant Magnetometer Sensitivity Matrix S11
 * @param[in] mredSens22
 *   Redundant Magnetometer Sensitivity Matrix S22
 * @param[in] mredSens33
 *   Redundant Magnetometer Sensitivity Matrix S33
 * @param[in] mredSens12
 *   Redundant Magnetometer Sensitivity Matrix S12
 * @param[in] mredSens13
 *   Redundant Magnetometer Sensitivity Matrix S13
 * @param[in] mredSens21
 *   Redundant Magnetometer Sensitivity Matrix S21
 * @param[in] mredSens23
 *   Redundant Magnetometer Sensitivity Matrix S23
 * @param[in] mredSens31
 *   Redundant Magnetometer Sensitivity Matrix S31
 * @param[in] mredSens32
 *   Redundant Magnetometer Sensitivity Matrix S32
 * @param[in] starAngle1
 *   StarTracker Mounting Transform Alpha Angle
 *   (in [deg] units)
 * @param[in] starAngle2
 *   StarTracker Mounting Transform Beta Angle
 *   (in [deg] units)
 * @param[in] starAngle3
 *   StarTracker Mounting Transform Gamma Angle
 *   (in [deg] units)
 * @param[in] starExposure
 *   exposure time register value
 * @param[in] starGain
 *   analog gain register value
 * @param[in] detectionThreshold
 *   StarTracker detection threshold
 * @param[in] starThreshold
 *   StarTracker star threshold
 * @param[in] maxStarMatched
 *   Maximum of stars that the star tracker will match
 * @param[in] starTimeoutTime
 *   Time allowed for detection
 * @param[in] maxStarPixel
 *   Maximum pixels in a star
 * @param[in] minStarPixel
 *   Minimum pixels in a star
 * @param[in] starErrorMargin
 *   % Error margin of the star identification
 *   (in [%] units)
 * @param[in] starDelayTime
 *   Delay Time
 *   (in [milliseconds] units)
 * @param[in] starCentX
 *   Pixel centroid X
 *   (valid range is between -5000  and 5000 )
 * @param[in] starCentY
 *   Pixel centroid Y
 *   (valid range is between -5000  and 5000 )
 * @param[in] starFocal
 *   Star Tracker Focal Length
 *   (in [mm] units)
 *   (valid range is between 5 mm and 7 mm)
 * @param[in] starLensK1
 *   First radial distortion coefficient
 *   (in [gain] units)
 *   (valid range is between -1 gain and 1 gain)
 * @param[in] starLensK2
 *   Second radial distortion coefficient
 *   (in [gain] units)
 *   (valid range is between -1 gain and 1 gain)
 * @param[in] starLensP1
 *   First tangential distortion coefficient
 *   (in [gain] units)
 *   (valid range is between -1 gain and 1 gain)
 * @param[in] starLensP2
 *   Second tangential distortion coefficients
 *   (in [gain] units)
 *   (valid range is between -1 gain and 1 gain)
 * @param[in] starWindowWidth
 *   Window width
 * @param[in] starTrackingMargin
 *   Tracking Margin
 * @param[in] starValidationMargin
 *   Validation Margin
 * @param[in] starModuleEnable
 *   Module Enable
 * @param[in] starLocationPredictionEnable
 *   LocationPredictionEnable
 * @param[in] reserved
 *   
 * @param[in] starSearchWidth
 *   Search Width
 * @param[in] ks
 *   Detumbling Spin Gain (Ks)
 *   (valid range is between 0  and 10000 )
 * @param[in] kd
 *   Detumbling Damping Gain (Kd)
 *   (valid range is between 0  and 10000 )
 * @param[in] wy_ref
 *   Reference spin rate (wy-ref). Must always be smaller than 0 for Y-spin
 *   (in [deg/s] units)
 *   (valid range is between -32000 deg/s and 32000 deg/s)
 * @param[in] kdf
 *   Fast BDot Detumbling Gain (Kdf)
 *   (valid range is between 0  and 100 )
 * @param[in] kh
 *   Y-Momentum Control Gain (Kh)
 *   (valid range is between 0  and 10000 )
 * @param[in] kn
 *   Y-momentum Nutation Damping Gain (Kn)
 *   (valid range is between 0  and 10000 )
 * @param[in] kp1
 *   Y-momentum Proportional Gain (Kp1)
 *   (valid range is between 0  and 100 )
 * @param[in] kd1
 *   Y-momentum Derivative Gain (Kd1)
 *   (valid range is between 0  and 100 )
 * @param[in] h_ref
 *   Reference Wheel Momentum (H-ref). Must always be smaller than 0
 *   (in [Nms] units)
 *   (valid range is between -10 Nms and 0 Nms)
 * @param[in] kp2
 *   RWheel Proportional Gain (Kp2)
 *   (valid range is between 0  and 100 )
 * @param[in] kd2
 *   RWheel Derivative Gain (Kd2)
 *   (valid range is between 0  and 100 )
 * @param[in] h_bias
 *   Y-Wheel Bias Momentum (H-bias)
 *   (in [Nms] units)
 *   (valid range is between -10 Nms and 10 Nms)
 * @param[in] sunPointFacet
 *   Satellite body axis that will align with sun vector
 * @param[in] wheelErrorHandling
 *   Enable/disable automatic transition from wheel control modes to Y-Thomson mode in case of wheel error
 * @param[in] kp3
 *   Tracking Proportional Gain (Kp3)
 *   (valid range is between 0  and 100 )
 * @param[in] kd3
 *   Tracking Derivative Gain (Kd3)
 *   (valid range is between 0  and 100 )
 * @param[in] ki3
 *   Tracking Integral Gain (Ki3)
 *   (valid range is between 0  and 100 )
 * @param[in] targetTrackFacet
 *   Satellite body axis that will point to target
 * @param[in] ixx
 *   Moment Of Inertia - Ixx
 *   (in [kg.m^2] units)
 *   (valid range is between 0 kg.m^2 and 10 kg.m^2)
 * @param[in] iyy
 *   Moment Of Inertia - Iyy
 *   (in [kg.m^2] units)
 *   (valid range is between 0 kg.m^2 and 10 kg.m^2)
 * @param[in] izz
 *   Moment Of Inertia - Izz
 *   (in [kg.m^2] units)
 *   (valid range is between 0 kg.m^2 and 10 kg.m^2)
 * @param[in] ixy
 *   Product Of Inertia - Ixy
 *   (in [kg.m^2] units)
 *   (valid range is between -10 kg.m^2 and 10 kg.m^2)
 * @param[in] ixz
 *   Product Of Inertia - Ixz
 *   (in [kg.m^2] units)
 *   (valid range is between -10 kg.m^2 and 10 kg.m^2)
 * @param[in] iyz
 *   Product Of Inertia - Iyz
 *   (in [kg.m^2] units)
 *   (valid range is between -10 kg.m^2 and 10 kg.m^2)
 * @param[in] magRateNoise
 *   Magnetometer Rate Filter System Noise
 *   (valid range is between 0  and 100 )
 * @param[in] ekfSysNoise
 *   EKF System Noise
 *   (valid range is between 0  and 100 )
 * @param[in] cssNoise
 *   CSS Measurement Noise
 *   (valid range is between 0  and 100 )
 * @param[in] sunNoise
 *   Sun Sensor Measurement Noise
 *   (valid range is between 0  and 100 )
 * @param[in] nadirNoise
 *   Nadir Sensor Measurement Noise
 *   (valid range is between 0  and 100 )
 * @param[in] magNoise
 *   Magnetometer Measurement Noise
 *   (valid range is between 0  and 100 )
 * @param[in] starNoise
 *   Star Tracker Measurement Noise
 *   (valid range is between 0  and 100 )
 * @param[in] useSunEst
 *   Use Sun Sensor measurement in EKF
 * @param[in] useNadirEst
 *   Use Nadir Sensor measurement in EKF
 * @param[in] useCssEst
 *   Use CSS measurement in EKF
 * @param[in] useStarEst
 *   Use Star Tracker measurement in EKF
 * @param[in] terminatorCheck
 *   Select to ignore Nadir sensor measurements when terminator is in FOV
 * @param[in] autoRecoverMtm
 *   Select whether automatic switch to redundant magnetometer should occur in case of failure
 * @param[in] magMode
 *   Mode describing which magnetometer is used for estimation and control
 * @param[in] magRawTlm2Selection
 *   Select which magnetometer and sampling to use for 2nd raw magnetometer tlm frame
 * @param[in] rateSensorErrorHandling
 *   Enable/disable automatic transition from MEMS rate estimation mode to RKF in case of rate sensor error
 * @param[in] wheelPowerOn30sDelay
 *   Delay wheel communications for 30s after power-cycle
 * @param[in] reserved
 *   
 * @param[in] cam1Cam2Period
 *   Cam1 and Cam2 sensor sampling period. Lower four bits are Cam1 period and upper four bits the Cam2 period. Setting period to zero for sensor will disable sampling of sensor.
 *   (in [s] units)
 * @param[in] aInclCoeff
 *   Inclination filter coefficient
 * @param[in] aRaanCoeff
 *   RAAN filter coefficient
 * @param[in] aEccCoeff
 *   Eccentricity filter coefficient
 * @param[in] aArgPerCoeff
 *   Argument of perigee filter coefficient
 * @param[in] aTimeCoeff
 *   Time filter coefficient
 * @param[in] aPosCoeff
 *   Position filter coefficient
 * @param[in] asgp4MaxPosError
 *   Maximum position error for asgp4 to continue working
 * @param[in] asgp4Filter
 *   The type of filter asgp4 is using
 * @param[in] asgp4Xp
 *   Polar coefficient xp
 * @param[in] asgp4Yp
 *   Polar coefficient yp
 * @param[in] asgp4GpsRollover
 *   GPS roll over number
 * @param[in] asgp4PosSdTh
 *   Maximum position standard deviation for asgp4 to operate
 * @param[in] asgp4VelSdTh
 *   Maximum velocity standard deviation for asgp4 to operate
 * @param[in] asgp4MinSat
 *   Minimum satellites for asgp4 to operate
 * @param[in] asgp4TimeGain
 *   Time offset compensation gain
 * @param[in] asgp4MaxLag
 *   Maximum lagged timestamp measurements to incorporate
 * @param[in] asgp4MinSamples
 *   Minimum samples to use for asgp4 process
 * @param[in] userConSettings
 *   Settings for user coded control mode(s)
 * @param[in] userEstSettings
 *   Settings for user coded estimation mode(s)
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 *      TcInvalidParam if the input parameter, magtorq1, was not a valid CUBEACP_AxisSelect_t enumeration
 *      TcInvalidParam if the input parameter, magtorq2, was not a valid CUBEACP_AxisSelect_t enumeration
 *      TcInvalidParam if the input parameter, magtorq3, was not a valid CUBEACP_AxisSelect_t enumeration
 *      TcInvalidParam if the input parameter, rW1Conf, was not a valid CUBEACP_AxisSelect_t enumeration
 *      TcInvalidParam if the input parameter, rW2Conf, was not a valid CUBEACP_AxisSelect_t enumeration
 *      TcInvalidParam if the input parameter, rW3Conf, was not a valid CUBEACP_AxisSelect_t enumeration
 *      TcInvalidParam if the input parameter, rW4Conf, was not a valid CUBEACP_AxisSelect_t enumeration
 *      TcInvalidParam if the input parameter, gyro1Conf, was not a valid CUBEACP_AxisSelect_t enumeration
 *      TcInvalidParam if the input parameter, gyro2Conf, was not a valid CUBEACP_AxisSelect_t enumeration
 *      TcInvalidParam if the input parameter, gyro3Conf, was not a valid CUBEACP_AxisSelect_t enumeration
 *      TcInvalidParam if the input parameter, css1Conf, was not a valid CUBEACP_AxisSelect_t enumeration
 *      TcInvalidParam if the input parameter, css2Conf, was not a valid CUBEACP_AxisSelect_t enumeration
 *      TcInvalidParam if the input parameter, css3Conf, was not a valid CUBEACP_AxisSelect_t enumeration
 *      TcInvalidParam if the input parameter, css4Conf, was not a valid CUBEACP_AxisSelect_t enumeration
 *      TcInvalidParam if the input parameter, css5Conf, was not a valid CUBEACP_AxisSelect_t enumeration
 *      TcInvalidParam if the input parameter, css6Conf, was not a valid CUBEACP_AxisSelect_t enumeration
 *      TcInvalidParam if the input parameter, css7Conf, was not a valid CUBEACP_AxisSelect_t enumeration
 *      TcInvalidParam if the input parameter, css8Conf, was not a valid CUBEACP_AxisSelect_t enumeration
 *      TcInvalidParam if the input parameter, css9Conf, was not a valid CUBEACP_AxisSelect_t enumeration
 *      TcInvalidParam if the input parameter, css10Conf, was not a valid CUBEACP_AxisSelect_t enumeration
 *      TcInvalidParam if the input parameter, starCentX, was outside of the range -5000  to 5000 
 *      TcInvalidParam if the input parameter, starCentY, was outside of the range -5000  to 5000 
 *      TcInvalidParam if the input parameter, starFocal, was outside of the range 5 mm to 7 mm
 *      TcInvalidParam if the input parameter, starLensK1, was outside of the range -1 gain to 1 gain
 *      TcInvalidParam if the input parameter, starLensK2, was outside of the range -1 gain to 1 gain
 *      TcInvalidParam if the input parameter, starLensP1, was outside of the range -1 gain to 1 gain
 *      TcInvalidParam if the input parameter, starLensP2, was outside of the range -1 gain to 1 gain
 *      TcInvalidParam if the input parameter, ks, was outside of the range 0  to 10000 
 *      TcInvalidParam if the input parameter, kd, was outside of the range 0  to 10000 
 *      TcInvalidParam if the input parameter, wy_ref, was outside of the range -32000 deg/s to 32000 deg/s
 *      TcInvalidParam if the input parameter, kdf, was outside of the range 0  to 100 
 *      TcInvalidParam if the input parameter, kh, was outside of the range 0  to 10000 
 *      TcInvalidParam if the input parameter, kn, was outside of the range 0  to 10000 
 *      TcInvalidParam if the input parameter, kp1, was outside of the range 0  to 100 
 *      TcInvalidParam if the input parameter, kd1, was outside of the range 0  to 100 
 *      TcInvalidParam if the input parameter, h_ref, was outside of the range -10 Nms to 0 Nms
 *      TcInvalidParam if the input parameter, kp2, was outside of the range 0  to 100 
 *      TcInvalidParam if the input parameter, kd2, was outside of the range 0  to 100 
 *      TcInvalidParam if the input parameter, h_bias, was outside of the range -10 Nms to 10 Nms
 *      TcInvalidParam if the input parameter, sunPointFacet, was not a valid CUBEACP_AxisSelect_t enumeration
 *      TcInvalidParam if the input parameter, kp3, was outside of the range 0  to 100 
 *      TcInvalidParam if the input parameter, kd3, was outside of the range 0  to 100 
 *      TcInvalidParam if the input parameter, ki3, was outside of the range 0  to 100 
 *      TcInvalidParam if the input parameter, targetTrackFacet, was not a valid CUBEACP_AxisSelect_t enumeration
 *      TcInvalidParam if the input parameter, ixx, was outside of the range 0 kg.m^2 to 10 kg.m^2
 *      TcInvalidParam if the input parameter, iyy, was outside of the range 0 kg.m^2 to 10 kg.m^2
 *      TcInvalidParam if the input parameter, izz, was outside of the range 0 kg.m^2 to 10 kg.m^2
 *      TcInvalidParam if the input parameter, ixy, was outside of the range -10 kg.m^2 to 10 kg.m^2
 *      TcInvalidParam if the input parameter, ixz, was outside of the range -10 kg.m^2 to 10 kg.m^2
 *      TcInvalidParam if the input parameter, iyz, was outside of the range -10 kg.m^2 to 10 kg.m^2
 *      TcInvalidParam if the input parameter, magRateNoise, was outside of the range 0  to 100 
 *      TcInvalidParam if the input parameter, ekfSysNoise, was outside of the range 0  to 100 
 *      TcInvalidParam if the input parameter, cssNoise, was outside of the range 0  to 100 
 *      TcInvalidParam if the input parameter, sunNoise, was outside of the range 0  to 100 
 *      TcInvalidParam if the input parameter, nadirNoise, was outside of the range 0  to 100 
 *      TcInvalidParam if the input parameter, magNoise, was outside of the range 0  to 100 
 *      TcInvalidParam if the input parameter, starNoise, was outside of the range 0  to 100 
 *      TcInvalidParam if the input parameter, magMode, was not a valid CUBEACP_MagModeVal_t enumeration
 *      TcInvalidParam if the input parameter, magRawTlm2Selection, was not a valid CUBEACP_MagModeVal_t enumeration
 *      TcInvalidParam if the input parameter, asgp4Filter, was not a valid CUBEACP_AsgpFilter_t enumeration
 ******************************************************************************/
uint16_t CUBEACP_FormatAdcsConfigCmd(uint8_t* tcBuffer, CUBEACP_AdcsConfig_t* setVal);

/***************************************************************************//**
 * Send a ADCS Run Mode command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @param[in] enabled
 *   Set ADCS enabled state. When disabled the CubeACP will not use the ADCS I2C bus
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 *      TcInvalidParam if the input parameter, enabled, was not a valid CUBEACP_AdcsRunMode_t enumeration
 ******************************************************************************/
uint16_t CUBEACP_FormatAdcsEnabledCmd(uint8_t* tcBuffer, CUBEACP_AdcsRunMode_t enabled);

/***************************************************************************//**
 * Send a ADCS Power Control command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @param[in] cubeControlSignalPower
 *   Control power to electronics of CubeControl Signal PIC
 * @param[in] cubeControlMotorPower
 *   Control power to electronics of CubeControl Motor PIC
 * @param[in] cubeSense1Power
 *   Control power to the CubeSense1
 * @param[in] cubeSense2Power
 *   Control power to the CubeSense2
 * @param[in] cubeStarPower
 *   Control power to the CubeStar
 * @param[in] cubeWheel1Power
 *   Control power to the CubeWheel1
 * @param[in] cubeWheel2Power
 *   Control power to the CubeWheel2
 * @param[in] cubeWheel3Power
 *   Control power to the CubeWheel3
 * @param[in] motorPower
 *   Control power to Motor electronics
 * @param[in] gpsLnaPower
 *   Control power to GPS LNA
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 *      TcInvalidParam if the input parameter, cubeControlSignalPower, was not a valid CUBEACP_PowerSelect_t enumeration
 *      TcInvalidParam if the input parameter, cubeControlMotorPower, was not a valid CUBEACP_PowerSelect_t enumeration
 *      TcInvalidParam if the input parameter, cubeSense1Power, was not a valid CUBEACP_PowerSelectCubeSense_t enumeration
 *      TcInvalidParam if the input parameter, cubeSense2Power, was not a valid CUBEACP_PowerSelectCubeSense_t enumeration
 *      TcInvalidParam if the input parameter, cubeStarPower, was not a valid CUBEACP_PowerSelect_t enumeration
 *      TcInvalidParam if the input parameter, cubeWheel1Power, was not a valid CUBEACP_PowerSelect_t enumeration
 *      TcInvalidParam if the input parameter, cubeWheel2Power, was not a valid CUBEACP_PowerSelect_t enumeration
 *      TcInvalidParam if the input parameter, cubeWheel3Power, was not a valid CUBEACP_PowerSelect_t enumeration
 *      TcInvalidParam if the input parameter, motorPower, was not a valid CUBEACP_PowerSelect_t enumeration
 *      TcInvalidParam if the input parameter, gpsLnaPower, was not a valid CUBEACP_PowerSelect_t enumeration
 ******************************************************************************/
uint16_t CUBEACP_FormatAdcsPowerCmd(uint8_t* tcBuffer, CUBEACP_AdcsPower_t* setVal);

/***************************************************************************//**
 * Send a ADCS System Configuration command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @param[in] acpType
 *   ACP Type
 * @param[in] specialControl
 *   Special Control Selection
 * @param[in] ccSignalVer
 *   CubeControl Signal Version
 * @param[in] ccMotorVer
 *   CubeControl Motor Version
 * @param[in] cs1Ver
 *   CubeSense1 Version
 * @param[in] cs2Ver
 *   CubeSense2 Version
 * @param[in] csCam1Type
 *   CubeSense1 Camera Type
 * @param[in] csCam2Type
 *   CubeSense2 Camera Type
 * @param[in] cubeStarVer
 *   CubeStar Version
 * @param[in] gpsType
 *   GPS Type
 * @param[in] hasRedMag
 *   Redundant MTM Included
 * @param[in] reserved
 *   
 * @param[in] mqx
 *   Magnetorquer-X Max Dipole
 *   (in [A.m^2] units)
 *   (valid range is between 0 A.m^2 and 2 A.m^2)
 * @param[in] mqy
 *   Magnetorquer-Y Max Dipole
 *   (in [A.m^2] units)
 *   (valid range is between 0 A.m^2 and 2 A.m^2)
 * @param[in] mqz
 *   Magnetorquer-Z Max Dipole
 *   (in [A.m^2] units)
 *   (valid range is between 0 A.m^2 and 2 A.m^2)
 * @param[in] mtTmin
 *   Magnetorquer On-time Resolution
 *   (in [s] units)
 *   (valid range is between 0 s and 1 s)
 * @param[in] mtTmax
 *   Magnetorquer Maximum On-time
 *   (in [s] units)
 *   (valid range is between 0 s and 1 s)
 * @param[in] nSatX
 *   RW-X Maximum Torque
 *   (in [N.m] units)
 *   (valid range is between 0 N.m and 0.1 N.m)
 * @param[in] nSatY
 *   RW-Y Maximum Torque
 *   (in [N.m] units)
 *   (valid range is between 0 N.m and 0.1 N.m)
 * @param[in] nSatZ
 *   RW-Z Maximum Torque
 *   (in [N.m] units)
 *   (valid range is between 0 N.m and 0.1 N.m)
 * @param[in] hSatX
 *   RW-X Maximum Momentum
 *   (in [Nms] units)
 *   (valid range is between 0 Nms and 0.1 Nms)
 * @param[in] hSatY
 *   RW-Y Maximum Momentum
 *   (in [Nms] units)
 *   (valid range is between 0 Nms and 0.1 Nms)
 * @param[in] hSatZ
 *   RW-Z Maximum Momentum
 *   (in [Nms] units)
 *   (valid range is between 0 Nms and 0.1 Nms)
 * @param[in] iwx
 *   RW-X Inertia
 *   (in [kg.m^2] units)
 *   (valid range is between 0 kg.m^2 and 0.001 kg.m^2)
 * @param[in] iwy
 *   RW-Y Inertia
 *   (in [kg.m^2] units)
 *   (valid range is between 0 kg.m^2 and 0.001 kg.m^2)
 * @param[in] iwz
 *   RW-Z Inertia
 *   (in [kg.m^2] units)
 *   (valid range is between 0 kg.m^2 and 0.001 kg.m^2)
 * @param[in] ndel
 *   RW Torque Increment
 *   (in [N.m] units)
 *   (valid range is between 0 N.m and 0.1 N.m)
 * @param[in] biasX_d1
 *   Primary MTM X-Bias d1
 *   (valid range is between -10  and 10 )
 * @param[in] biasY_d1
 *   Primary MTM Y-Bias d1
 *   (valid range is between -10  and 10 )
 * @param[in] biasZ_d1
 *   Primary MTM Z-Bias d1
 *   (valid range is between -10  and 10 )
 * @param[in] biasX_d2
 *   Primary MTM X-Bias d2
 *   (valid range is between -10000  and 10000 )
 * @param[in] biasY_d2
 *   Primary MTM Y-Bias d2
 *   (valid range is between -10000  and 10000 )
 * @param[in] biasZ_d2
 *   Primary MTM Z-Bias d2
 *   (valid range is between -10000  and 10000 )
 * @param[in] sensX_s1
 *   Primary MTM X-Sens s1
 *   (valid range is between -1  and 1 )
 * @param[in] sensY_s1
 *   Primary MTM Y-Sens s1
 *   (valid range is between -1  and 1 )
 * @param[in] sensZ_s1
 *   Primary MTM Z-Sens s1
 *   (valid range is between -1  and 1 )
 * @param[in] sensX_s2
 *   Primary MTM X-Sens s2
 *   (valid range is between -10  and 10 )
 * @param[in] sensY_s2
 *   Primary MTM Y-Sens s2
 *   (valid range is between -10  and 10 )
 * @param[in] sensZ_s2
 *   Primary MTM Z-Sens s2
 *   (valid range is between -10  and 10 )
 * @param[in] red_BiasX_d1
 *   Redundant MTM X-Bias d1
 *   (valid range is between -10  and 10 )
 * @param[in] red_BiasY_d1
 *   Redundant MTM Y-Bias d1
 *   (valid range is between -10  and 10 )
 * @param[in] red_BiasZ_d1
 *   Redundant MTM Z-Bias d1
 *   (valid range is between -10  and 10 )
 * @param[in] red_BiasX_d2
 *   Redundant MTM X-Bias d2
 *   (valid range is between -10000  and 10000 )
 * @param[in] red_BiasY_d2
 *   Redundant MTM Y-Bias d2
 *   (valid range is between -10000  and 10000 )
 * @param[in] red_BiasZ_d2
 *   Redundant MTM Z-Bias d2
 *   (valid range is between -10000  and 10000 )
 * @param[in] red_SensX_s1
 *   Redundant MTM X-Sens s1
 *   (valid range is between -1  and 1 )
 * @param[in] red_SensY_s1
 *   Redundant MTM Y-Sens s1
 *   (valid range is between -1  and 1 )
 * @param[in] red_SensZ_s1
 *   Redundant MTM Z-Sens s1
 *   (valid range is between -1  and 1 )
 * @param[in] red_SensX_s2
 *   Redundant MTM X-Sens s2
 *   (valid range is between -10  and 10 )
 * @param[in] red_SensY_s2
 *   Redundant MTM Y-Sens s2
 *   (valid range is between -10  and 10 )
 * @param[in] red_SensZ_s2
 *   Redundant MTM Z-Sens s2
 *   (valid range is between -10  and 10 )
 * @param[in] ccsEnablePort
 *   CC Signal Enable GPIO port
 * @param[in] ccsEnablePin
 *   CC Signal Enable GPIO port pin
 * @param[in] ccmEnablePort
 *   CC Motor Enable GPIO port
 * @param[in] ccmEnablePin
 *   CC Motor Enable GPIO port pin
 * @param[in] cccEnablePort
 *   CC Common Enable GPIO port
 * @param[in] cccEnablePin
 *   CC Common Enable GPIO port pin
 * @param[in] cSense1EnablePort
 *   CubeSense1 Enable GPIO port
 * @param[in] cSense1EnablePin
 *   CubeSense1 Enable GPIO port pin
 * @param[in] cSense2EnablePort
 *   CubeSense2 Enable GPIO port
 * @param[in] cSense2EnablePin
 *   CubeSense2 Enable GPIO port pin
 * @param[in] cStarEnablePort
 *   CubeStar Enable GPIO port
 * @param[in] cStarEnablePin
 *   CubeStar Enable GPIO port pin
 * @param[in] cW1EnablePort
 *   CubeWheel1 Enable GPIO port
 * @param[in] cW1EnablePin
 *   CubeWheel1 Enable GPIO port pin
 * @param[in] cW2EnablePort
 *   CubeWheel2 Enable GPIO port
 * @param[in] cW2EnablePin
 *   CubeWheel2 Enable GPIO port pin
 * @param[in] cW3EnablePort
 *   CubeWheel3 Enable GPIO port
 * @param[in] cW3EnablePin
 *   CubeWheel3 Enable GPIO port pin
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 *      TcInvalidParam if the input parameter, acpType, was not a valid CUBEACP_AcpProgramType_t enumeration
 *      TcInvalidParam if the input parameter, specialControl, was not a valid CUBEACP_SpecialConSelect_t enumeration
 *      TcInvalidParam if the input parameter, csCam1Type, was not a valid CUBEACP_CsCamType_t enumeration
 *      TcInvalidParam if the input parameter, csCam2Type, was not a valid CUBEACP_CsCamType_t enumeration
 *      TcInvalidParam if the input parameter, gpsType, was not a valid CUBEACP_GpsSelect_t enumeration
 *      TcInvalidParam if the input parameter, mqx, was outside of the range 0 A.m^2 to 2 A.m^2
 *      TcInvalidParam if the input parameter, mqy, was outside of the range 0 A.m^2 to 2 A.m^2
 *      TcInvalidParam if the input parameter, mqz, was outside of the range 0 A.m^2 to 2 A.m^2
 *      TcInvalidParam if the input parameter, mtTmin, was outside of the range 0 s to 1 s
 *      TcInvalidParam if the input parameter, mtTmax, was outside of the range 0 s to 1 s
 *      TcInvalidParam if the input parameter, nSatX, was outside of the range 0 N.m to 0.1 N.m
 *      TcInvalidParam if the input parameter, nSatY, was outside of the range 0 N.m to 0.1 N.m
 *      TcInvalidParam if the input parameter, nSatZ, was outside of the range 0 N.m to 0.1 N.m
 *      TcInvalidParam if the input parameter, hSatX, was outside of the range 0 Nms to 0.1 Nms
 *      TcInvalidParam if the input parameter, hSatY, was outside of the range 0 Nms to 0.1 Nms
 *      TcInvalidParam if the input parameter, hSatZ, was outside of the range 0 Nms to 0.1 Nms
 *      TcInvalidParam if the input parameter, iwx, was outside of the range 0 kg.m^2 to 0.001 kg.m^2
 *      TcInvalidParam if the input parameter, iwy, was outside of the range 0 kg.m^2 to 0.001 kg.m^2
 *      TcInvalidParam if the input parameter, iwz, was outside of the range 0 kg.m^2 to 0.001 kg.m^2
 *      TcInvalidParam if the input parameter, ndel, was outside of the range 0 N.m to 0.1 N.m
 *      TcInvalidParam if the input parameter, biasX_d1, was outside of the range -10  to 10 
 *      TcInvalidParam if the input parameter, biasY_d1, was outside of the range -10  to 10 
 *      TcInvalidParam if the input parameter, biasZ_d1, was outside of the range -10  to 10 
 *      TcInvalidParam if the input parameter, biasX_d2, was outside of the range -10000  to 10000 
 *      TcInvalidParam if the input parameter, biasY_d2, was outside of the range -10000  to 10000 
 *      TcInvalidParam if the input parameter, biasZ_d2, was outside of the range -10000  to 10000 
 *      TcInvalidParam if the input parameter, sensX_s1, was outside of the range -1  to 1 
 *      TcInvalidParam if the input parameter, sensY_s1, was outside of the range -1  to 1 
 *      TcInvalidParam if the input parameter, sensZ_s1, was outside of the range -1  to 1 
 *      TcInvalidParam if the input parameter, sensX_s2, was outside of the range -10  to 10 
 *      TcInvalidParam if the input parameter, sensY_s2, was outside of the range -10  to 10 
 *      TcInvalidParam if the input parameter, sensZ_s2, was outside of the range -10  to 10 
 *      TcInvalidParam if the input parameter, red_BiasX_d1, was outside of the range -10  to 10 
 *      TcInvalidParam if the input parameter, red_BiasY_d1, was outside of the range -10  to 10 
 *      TcInvalidParam if the input parameter, red_BiasZ_d1, was outside of the range -10  to 10 
 *      TcInvalidParam if the input parameter, red_BiasX_d2, was outside of the range -10000  to 10000 
 *      TcInvalidParam if the input parameter, red_BiasY_d2, was outside of the range -10000  to 10000 
 *      TcInvalidParam if the input parameter, red_BiasZ_d2, was outside of the range -10000  to 10000 
 *      TcInvalidParam if the input parameter, red_SensX_s1, was outside of the range -1  to 1 
 *      TcInvalidParam if the input parameter, red_SensY_s1, was outside of the range -1  to 1 
 *      TcInvalidParam if the input parameter, red_SensZ_s1, was outside of the range -1  to 1 
 *      TcInvalidParam if the input parameter, red_SensX_s2, was outside of the range -10  to 10 
 *      TcInvalidParam if the input parameter, red_SensY_s2, was outside of the range -10  to 10 
 *      TcInvalidParam if the input parameter, red_SensZ_s2, was outside of the range -10  to 10 
 *      TcInvalidParam if the input parameter, ccsEnablePort, was not a valid CUBEACP_GpioPort_t enumeration
 *      TcInvalidParam if the input parameter, ccsEnablePin, was not a valid CUBEACP_GpioPortPin_t enumeration
 *      TcInvalidParam if the input parameter, ccmEnablePort, was not a valid CUBEACP_GpioPort_t enumeration
 *      TcInvalidParam if the input parameter, ccmEnablePin, was not a valid CUBEACP_GpioPortPin_t enumeration
 *      TcInvalidParam if the input parameter, cccEnablePort, was not a valid CUBEACP_GpioPort_t enumeration
 *      TcInvalidParam if the input parameter, cccEnablePin, was not a valid CUBEACP_GpioPortPin_t enumeration
 *      TcInvalidParam if the input parameter, cSense1EnablePort, was not a valid CUBEACP_GpioPort_t enumeration
 *      TcInvalidParam if the input parameter, cSense1EnablePin, was not a valid CUBEACP_GpioPortPin_t enumeration
 *      TcInvalidParam if the input parameter, cSense2EnablePort, was not a valid CUBEACP_GpioPort_t enumeration
 *      TcInvalidParam if the input parameter, cSense2EnablePin, was not a valid CUBEACP_GpioPortPin_t enumeration
 *      TcInvalidParam if the input parameter, cStarEnablePort, was not a valid CUBEACP_GpioPort_t enumeration
 *      TcInvalidParam if the input parameter, cStarEnablePin, was not a valid CUBEACP_GpioPortPin_t enumeration
 *      TcInvalidParam if the input parameter, cW1EnablePort, was not a valid CUBEACP_GpioPort_t enumeration
 *      TcInvalidParam if the input parameter, cW1EnablePin, was not a valid CUBEACP_GpioPortPin_t enumeration
 *      TcInvalidParam if the input parameter, cW2EnablePort, was not a valid CUBEACP_GpioPort_t enumeration
 *      TcInvalidParam if the input parameter, cW2EnablePin, was not a valid CUBEACP_GpioPortPin_t enumeration
 *      TcInvalidParam if the input parameter, cW3EnablePort, was not a valid CUBEACP_GpioPort_t enumeration
 *      TcInvalidParam if the input parameter, cW3EnablePin, was not a valid CUBEACP_GpioPortPin_t enumeration
 ******************************************************************************/
uint16_t CUBEACP_FormatAdcsSystemConfigCmd(uint8_t* tcBuffer, CUBEACP_AdcsSystemConfig_t* setVal);

/***************************************************************************//**
 * Send a ASGP4 Run Mode command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @param[in] asgp4ModeSelection
 *   ASGP4 enabled state
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 *      TcInvalidParam if the input parameter, asgp4ModeSelection, was not a valid CUBEACP_Asgp4ModeSelect_t enumeration
 ******************************************************************************/
uint16_t CUBEACP_FormatAsgp4ModeCmd(uint8_t* tcBuffer, CUBEACP_Asgp4ModeSelect_t asgp4ModeSelection);

/***************************************************************************//**
 * Send a Augmented-SGP4 Parameters command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatASgp4ParamsCmd(uint8_t* tcBuffer, CUBEACP_AdcsConfig_t* setVal);

/***************************************************************************//**
 * Send a ASGP4 Trigger command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatAsgp4TriggerCmd(uint8_t* tcBuffer);

/***************************************************************************//**
 * Send a Clear Errors command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @param[in] aDCSErrors
 *   Clear ADCS error flags
 * @param[in] hKErrors
 *   Clear HK Error flags
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatClearErrorsCmd(uint8_t* tcBuffer, CUBEACP_ClearErrors_t* setVal);

/***************************************************************************//**
 * Send a Commanded Attitude Angles command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @param[in] roll
 *   Commanded roll angle
 *   (in [deg] units)
 *   (valid range is between -9000 deg and 9000 deg)
 * @param[in] pitch
 *   Commanded pitch angle
 *   (in [deg] units)
 *   (valid range is between -18000 deg and 18000 deg)
 * @param[in] yaw
 *   Commanded yaw angle
 *   (in [deg] units)
 *   (valid range is between -18000 deg and 18000 deg)
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 *      TcInvalidParam if the input parameter, roll, was outside of the range -9000 deg to 9000 deg
 *      TcInvalidParam if the input parameter, pitch, was outside of the range -18000 deg to 18000 deg
 *      TcInvalidParam if the input parameter, yaw, was outside of the range -18000 deg to 18000 deg
 ******************************************************************************/
uint16_t CUBEACP_FormatCmdAttitudeCmd(uint8_t* tcBuffer, CUBEACP_CmdAttitude_t* setVal);

/***************************************************************************//**
 * Send a Tracking Controller Target Reference command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @param[in] longRef
 *   Geocentric longitude of target
 *   (in [deg] units)
 *   (valid range is between 0 deg and 360 deg)
 * @param[in] latRef
 *   Geocentric latitude of target
 *   (in [deg] units)
 *   (valid range is between -90 deg and 90 deg)
 * @param[in] altRef
 *   Geocentric altitude of target
 *   (in [meter] units)
 *   (valid range is between -20000 meter and 40000000 meter)
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 *      TcInvalidParam if the input parameter, longRef, was outside of the range 0 deg to 360 deg
 *      TcInvalidParam if the input parameter, latRef, was outside of the range -90 deg to 90 deg
 *      TcInvalidParam if the input parameter, altRef, was outside of the range -20000 meter to 40000000 meter
 ******************************************************************************/
uint16_t CUBEACP_FormatCmdTrackingTargetCmd(uint8_t* tcBuffer, F32 longRef, F32 latRef, F32 altRef);

/***************************************************************************//**
 * Send a Set Attitude Control Mode command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @param[in] controlModeSelection
 *   Attitude control mode
 * @param[in] timeout
 *   Control timeout duration. Control will revert to None when timer reaches zero. 0xFFFF for infinite timeout
 *   (in [s] units)
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 *      TcInvalidParam if the input parameter, controlModeSelection, was not a valid CUBEACP_ConModeSelect_t enumeration
 ******************************************************************************/
uint16_t CUBEACP_FormatControlModeCmd(uint8_t* tcBuffer, CUBEACP_ControlMode_t* setVal);

/***************************************************************************//**
 * Send a Convert to JPG file command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @param[in] srcFileCtr
 *   Source File Counter
 * @param[in] qualityFactor
 *   Quality Factor
 * @param[in] whiteBalance
 *   White Balance
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatConvertCmd(uint8_t* tcBuffer, U8 srcFileCtr, U8 qualityFactor, U8 whiteBalance);

/***************************************************************************//**
 * Send a CSS Configuration command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatCssConfigCmd(uint8_t* tcBuffer, CUBEACP_AdcsConfig_t* setVal);

/***************************************************************************//**
 * Send a CubeSense Configuration command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatCubeSenseConfigCmd(uint8_t* tcBuffer, CUBEACP_AdcsConfig_t* setVal);

/***************************************************************************//**
 * Send a Deploy Magnetometer Boom command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @param[in] timeout
 *   Deployment actuation timeout value
 *   (in [s] units)
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatDeployMagnetometerCmd(uint8_t* tcBuffer, U8 timeout);

/***************************************************************************//**
 * Send a Set Detumbling Control Parameters command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatDetumbleParamsCmd(uint8_t* tcBuffer, CUBEACP_AdcsConfig_t* setVal);

/***************************************************************************//**
 * Send a Set Attitude Estimation Mode command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @param[in] estimModeSelection
 *   Attitude estimation mode
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 *      TcInvalidParam if the input parameter, estimModeSelection, was not a valid CUBEACP_EstimModeSelect_t enumeration
 ******************************************************************************/
uint16_t CUBEACP_FormatEstimModeCmd(uint8_t* tcBuffer, CUBEACP_EstimModeSelect_t estimModeSelection);

/***************************************************************************//**
 * Send a Estimation Parameters command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatEstimParamsCmd(uint8_t* tcBuffer, CUBEACP_AdcsConfig_t* setVal);

/***************************************************************************//**
 * Send a Set Rate Gyro Configuration command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatGyroConfigCmd(uint8_t* tcBuffer, CUBEACP_AdcsConfig_t* setVal);

/***************************************************************************//**
 * Send a Inertial Pointing Reference Vector command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @param[in] inertialRefX
 *   Inertial Reference X
 * @param[in] inertialRefY
 *   Inertial Reference Y
 * @param[in] inertialRefZ
 *   Inertial Reference Z
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatInertialPointReferenceCmd(uint8_t* tcBuffer, F64 inertialRefX, F64 inertialRefY, F64 inertialRefZ);

/***************************************************************************//**
 * Send a SD Log1 Configuration command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @param[in] logSelection
 *   Log Selection - up to 80 flags indicating which telemetry frames should be logged
 * @param[in] period
 *   Log period. Set to 0 to disable logging
 * @param[in] destination
 *   Which SD card to use to store log file
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 *      TcInvalidParam if the input parameter, destination, was not a valid CUBEACP_SdLogSelect_t enumeration
 ******************************************************************************/
uint16_t CUBEACP_FormatLogSdConfig1Cmd(uint8_t* tcBuffer, U8* logSelection, U16 period, CUBEACP_SdLogSelect_t destination);

/***************************************************************************//**
 * Send a SD Log2 Configuration command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @param[in] logSelection
 *   Log Selection - up to 80 flags indicating which telemetry frames should be logged
 * @param[in] period
 *   Log period. Set to 0 to disable logging
 * @param[in] destination
 *   Which SD card to use to store log file
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 *      TcInvalidParam if the input parameter, destination, was not a valid CUBEACP_SdLogSelect_t enumeration
 ******************************************************************************/
uint16_t CUBEACP_FormatLogSdConfig2Cmd(uint8_t* tcBuffer, U8* logSelection, U16 period, CUBEACP_SdLogSelect_t destination);

/***************************************************************************//**
 * Send a UART Log Configuration command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @param[in] selection
 *   Log Selection - up to 80 flags indicating which telemetry frames should be logged
 * @param[in] period
 *   Log period. Set to 0 to disable logging
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatLogUartConfigCmd(uint8_t* tcBuffer, U8* selection, U16 period);

/***************************************************************************//**
 * Send a Magnetometer Configuration command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatMagConfigCmd(uint8_t* tcBuffer, CUBEACP_AdcsConfig_t* setVal);

/***************************************************************************//**
 * Send a Set Mode of Magnetometer Operation command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @param[in] modeSetting
 *   Mode describing which magnetometer is used for estimation and control
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 *      TcInvalidParam if the input parameter, modeSetting, was not a valid CUBEACP_MagModeVal_t enumeration
 ******************************************************************************/
uint16_t CUBEACP_FormatMagModeCmd(uint8_t* tcBuffer, CUBEACP_MagModeVal_t modeSetting);

/***************************************************************************//**
 * Send a Set Magnetorquer Configuration command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatMagtorqConfigCmd(uint8_t* tcBuffer, CUBEACP_AdcsConfig_t* setVal);

/***************************************************************************//**
 * Send a Moment of Inertia Matrix command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatMoICmd(uint8_t* tcBuffer, CUBEACP_AdcsConfig_t* setVal);

/***************************************************************************//**
 * Send a Set SGP4 Orbit Argument of Perigee command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatOrbitArgPerCmd(uint8_t* tcBuffer, F64 argPerigee);

/***************************************************************************//**
 * Send a Set SGP4 Orbit B-Star Drag term command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatOrbitBStarCmd(uint8_t* tcBuffer, F64 bstar);

/***************************************************************************//**
 * Send a Set SGP4 Orbit Eccentricity command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatOrbitEccentricityCmd(uint8_t* tcBuffer, F64 eccentricity);

/***************************************************************************//**
 * Send a Set SGP4 Orbit Epoch command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatOrbitEpochCmd(uint8_t* tcBuffer, F64 epoch);

/***************************************************************************//**
 * Send a Set SGP4 Orbit Inclination command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatOrbitInclinationCmd(uint8_t* tcBuffer, F64 inclination);

/***************************************************************************//**
 * Send a Set SGP4 Orbit Mean Anomaly command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatOrbitMeanAnomCmd(uint8_t* tcBuffer, F64 meanAnomaly);

/***************************************************************************//**
 * Send a Set SGP4 Orbit Mean Motion command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatOrbitMeanMotCmd(uint8_t* tcBuffer, F64 meanMotion);

/***************************************************************************//**
 * Send a SGP4 Orbit Parameters command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @param[in] inclination
 *   Inclination
 *   (in [deg] units)
 *   (valid range is between 0 deg and 180 deg)
 * @param[in] eccentricity
 *   Eccentricity
 *   (valid range is between 0  and 1 )
 * @param[in] raan
 *   Right-ascension of the Ascending Node
 *   (in [deg] units)
 *   (valid range is between 0 deg and 360 deg)
 * @param[in] argPerigee
 *   Argument of Perigee
 *   (in [deg] units)
 *   (valid range is between 0 deg and 360 deg)
 * @param[in] bstar
 *   B-Star drag term
 *   (valid range is between 0  and 1 )
 * @param[in] meanMotion
 *   Mean Motion
 *   (in [orbits/day] units)
 *   (valid range is between 0 orbits/day and 20 orbits/day)
 * @param[in] meanAnomaly
 *   Mean Anomaly
 *   (in [deg] units)
 *   (valid range is between 0 deg and 360 deg)
 * @param[in] epoch
 *   Epoch (year.day)
 *   (in [year.day] units)
 *   (valid range is between 0 year.day and 100000 year.day)
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 *      TcInvalidParam if the input parameter, inclination, was outside of the range 0 deg to 180 deg
 *      TcInvalidParam if the input parameter, eccentricity, was outside of the range 0  to 1 
 *      TcInvalidParam if the input parameter, raan, was outside of the range 0 deg to 360 deg
 *      TcInvalidParam if the input parameter, argPerigee, was outside of the range 0 deg to 360 deg
 *      TcInvalidParam if the input parameter, bstar, was outside of the range 0  to 1 
 *      TcInvalidParam if the input parameter, meanMotion, was outside of the range 0 orbits/day to 20 orbits/day
 *      TcInvalidParam if the input parameter, meanAnomaly, was outside of the range 0 deg to 360 deg
 *      TcInvalidParam if the input parameter, epoch, was outside of the range 0 year.day to 100000 year.day
 ******************************************************************************/
uint16_t CUBEACP_FormatOrbitParametersCmd(uint8_t* tcBuffer, CUBEACP_OrbitParameters_t* setVal);

/***************************************************************************//**
 * Send a Set SGP4 Orbit RAAN command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatOrbitRaanCmd(uint8_t* tcBuffer, F64 raan);

/***************************************************************************//**
 * Send a Redundant Magnetometer Configuration command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatRedMagConfigCmd(uint8_t* tcBuffer, CUBEACP_AdcsConfig_t* setVal);

/***************************************************************************//**
 * Send a Set Reaction Wheel Control Parameters command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatRWheelParamsCmd(uint8_t* tcBuffer, CUBEACP_AdcsConfig_t* setVal);

/***************************************************************************//**
 * Send a Save Configuration command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatSaveConfigCmd(uint8_t* tcBuffer);

/***************************************************************************//**
 * Send a Save Image command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @param[in] cameraSelect
 *   Camera Selection
 *   (in [s] units)
 * @param[in] imageSize
 *   Image size selection
 *   (in [s] units)
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 *      TcInvalidParam if the input parameter, cameraSelect, was not a valid CUBEACP_CamSelect_t enumeration
 *      TcInvalidParam if the input parameter, imageSize, was not a valid CUBEACP_ImSize_t enumeration
 ******************************************************************************/
uint16_t CUBEACP_FormatSaveImageCmd(uint8_t* tcBuffer, CUBEACP_SaveImage_t* setVal);

/***************************************************************************//**
 * Send a Save Orbit Parameters command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatSaveOrbitParamsCmd(uint8_t* tcBuffer);

/***************************************************************************//**
 * Send a Set Star Tracker Configuration command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatStarConfigCmd(uint8_t* tcBuffer, CUBEACP_AdcsConfig_t* setVal);

/***************************************************************************//**
 * Send a Set Magnetorquer Output command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @param[in] torquerX
 *   Commanded X-torquer duty cycle
 *   (valid range is between -800  and 800 )
 * @param[in] torquerY
 *   Commanded Y-torquer duty cycle
 *   (valid range is between -800  and 800 )
 * @param[in] torquerZ
 *   Commanded Z-torquer duty cycle
 *   (valid range is between -800  and 800 )
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 *      TcInvalidParam if the input parameter, torquerX, was outside of the range -800  to 800 
 *      TcInvalidParam if the input parameter, torquerY, was outside of the range -800  to 800 
 *      TcInvalidParam if the input parameter, torquerZ, was outside of the range -800  to 800 
 ******************************************************************************/
uint16_t CUBEACP_FormatTorquerCmdCmd(uint8_t* tcBuffer, CUBEACP_TorquerCmd_t* setVal);

/***************************************************************************//**
 * Send a Set Tracking Controller Gain Parameters command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatTrackingParamsCmd(uint8_t* tcBuffer, CUBEACP_AdcsConfig_t* setVal);

/***************************************************************************//**
 * Send a Trigger ADCS Loop command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatTriggerAdcsCmd(uint8_t* tcBuffer);

/***************************************************************************//**
 * Send a Trigger ADCS Loop with Simulated Sensor Data command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @param[in] unixTime
 *   Unix time for iteration
 *   (in [s] units)
 * @param[in] cssRaw1
 *   CSS1 raw measurement
 * @param[in] cssRaw2
 *   CSS2 raw measurement
 * @param[in] cssRaw3
 *   CSS3 raw measurement
 * @param[in] cssRaw4
 *   CSS4 raw measurement
 * @param[in] cssRaw5
 *   CSS5 raw measurement
 * @param[in] cssRaw6
 *   CSS6 raw measurement
 * @param[in] cssRaw7
 *   CSS7 raw measurement
 * @param[in] cssRaw8
 *   CSS8 raw measurement
 * @param[in] cssRaw9
 *   CSS9 raw measurement
 * @param[in] cssRaw10
 *   CSS10 raw measurement
 * @param[in] cam1RawX
 *   Cam1 sensor raw X angle
 * @param[in] cam1RawY
 *   Cam1 sensor raw Y angle
 * @param[in] cam1Busy
 *   Cam1 sensor capture status
 * @param[in] cam1Result
 *   Cam1 sensor detection result
 * @param[in] cam2RawX
 *   Cam2 sensor raw X angle
 * @param[in] cam2RawY
 *   Cam2 sensor raw Y angle
 * @param[in] cam2Busy
 *   Cam2 sensor capture status
 * @param[in] cam2Result
 *   Cam2 sensor detection result
 * @param[in] magRawX
 *   Raw magnetometer X measurement
 * @param[in] magRawY
 *   Raw magnetometer Y measurement
 * @param[in] magRawZ
 *   Raw magnetometer Z measurement
 * @param[in] rateRawX
 *   Raw X rate sensor measurement
 * @param[in] rateRawY
 *   Raw Y rate sensor measurement
 * @param[in] rateRawZ
 *   Raw Z rate sensor measurement
 * @param[in] wheelRawX
 *   Raw X wheel speed measurement
 *   (in [rpm] units)
 * @param[in] wheelRawY
 *   Raw Y wheel speed measurement
 *   (in [rpm] units)
 * @param[in] wheelRawZ
 *   Raw Z wheel speed measurement
 *   (in [rpm] units)
 * @param[in] star1CameraX
 *   Star1 camera X-vector
 * @param[in] star1CameraY
 *   Star1 camera Y-vector
 * @param[in] star1CameraZ
 *   Star1 camera Z-vector
 * @param[in] star1InertialX
 *   Star1 inertial X-vector
 * @param[in] star1InertialY
 *   Star1 inertial Y-vector
 * @param[in] star1InertialZ
 *   Star1 inertial Z-vector
 * @param[in] star2CameraX
 *   Star2 camera X-vector
 * @param[in] star2CameraY
 *   Star2 camera Y-vector
 * @param[in] star2CameraZ
 *   Star2 camera Z-vector
 * @param[in] star2InertialX
 *   Star2 inertial X-vector
 * @param[in] star2InertialY
 *   Star2 inertial Y-vector
 * @param[in] star2InertialZ
 *   Star2 inertial Z-vector
 * @param[in] star3CameraX
 *   Star3 camera X-vector
 * @param[in] star3CameraY
 *   Star3 camera Y-vector
 * @param[in] star3CameraZ
 *   Star3 camera Z-vector
 * @param[in] star3InertialX
 *   Star3 inertial X-vector
 * @param[in] star3InertialY
 *   Star3 inertial Y-vector
 * @param[in] star3InertialZ
 *   Star3 inertial Z-vector
 * @param[in] gpsSolutionStatus
 *   GPS Solution Status
 * @param[in] gpsWeek
 *   GPS Reference Week
 * @param[in] gpsTimeMs
 *   GPS Time Milliseconds
 *   (in [ms] units)
 * @param[in] posEcefX
 *   ECEF Position X
 *   (in [m] units)
 * @param[in] velEcefX
 *   ECEF Velocity X
 *   (in [m/s] units)
 * @param[in] posEcefY
 *   ECEF Position Y
 *   (in [m] units)
 * @param[in] velEcefY
 *   ECEF Velocity Y
 *   (in [m/s] units)
 * @param[in] posEcefZ
 *   ECEF Position Z
 *   (in [m] units)
 * @param[in] velEcefZ
 *   ECEF Velocity Z
 *   (in [m/s] units)
 * @param[in] stdDevPosX
 *   X-pos Standard Deviation
 *   (in [m] units)
 * @param[in] stdDevPosY
 *   Y-pos Standard Deviation
 *   (in [m] units)
 * @param[in] stdDevPosZ
 *   Z-pos Standard Deviation
 *   (in [m] units)
 * @param[in] stdDevVelX
 *   X-vel Standard Deviation
 *   (in [m/s] units)
 * @param[in] stdDevVelY
 *   Y-vel Standard Deviation
 *   (in [m/s] units)
 * @param[in] stdDevVelZ
 *   Z-vel Standard Deviation
 *   (in [m/s] units)
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 *      TcInvalidParam if the input parameter, gpsSolutionStatus, was not a valid CUBEACP_GpsSolutionStatus_t enumeration
 ******************************************************************************/
uint16_t CUBEACP_FormatTriggerAdcsSensorCmd(uint8_t* tcBuffer, CUBEACP_TriggerAdcsSensor_t* setVal);

/***************************************************************************//**
 * Send a User-coded Controller and Estimator Parameters command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatUserConEstParamsCmd(uint8_t* tcBuffer, CUBEACP_AdcsConfig_t* setVal);

/***************************************************************************//**
 * Send a Set Wheel Configuration command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatWheelConfigCmd(uint8_t* tcBuffer, CUBEACP_AdcsConfig_t* setVal);

/***************************************************************************//**
 * Send a Set Wheel Speed command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @param[in] wheelX
 *   Commanded X-wheel speed
 *   (in [rpm] units)
 *   (valid range is between -8000 rpm and 8000 rpm)
 * @param[in] wheelY
 *   Commanded Y-wheel speed
 *   (in [rpm] units)
 *   (valid range is between -8000 rpm and 8000 rpm)
 * @param[in] wheelZ
 *   Commanded Z-wheel speed
 *   (in [rpm] units)
 *   (valid range is between -8000 rpm and 8000 rpm)
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 *      TcInvalidParam if the input parameter, wheelX, was outside of the range -8000 rpm to 8000 rpm
 *      TcInvalidParam if the input parameter, wheelY, was outside of the range -8000 rpm to 8000 rpm
 *      TcInvalidParam if the input parameter, wheelZ, was outside of the range -8000 rpm to 8000 rpm
 ******************************************************************************/
uint16_t CUBEACP_FormatWheelSpeedCmdCmd(uint8_t* tcBuffer, CUBEACP_WheelSpeedCmd_t* setVal);

/***************************************************************************//**
 * Send a Set Y-Wheel Control Parameters command to the CubeACP
 *
 * @param[in] nodeid
 *   identifier of the node on the communications bus
 * @return
 *   Returns a value from the uint16_t enumeration:
 *      CubeLibOk if the command was sent without error
 *      One of the I2C enumeration values in case of I2C communications error
 ******************************************************************************/
uint16_t CUBEACP_FormatYWheelParamsCmd(uint8_t* tcBuffer, CUBEACP_AdcsConfig_t* setVal);


#endif  // define __CUBECOMPUTER4CONTROLPROGRAM7_H
